<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>Clock In/Out Tracker</title>
				<link rel="manifest" href="./manifest.json">
					<link rel="icon" href="./icons/favicon.ico" type="image/x-icon">
						<style>
							body {
								font-family: Arial, sans-serif;
								margin: 50px;
							}
						.container {
							max-width: 300px;
							margin: auto;
							text-align: center;
						}
						input[type="text"], input[type="datetime-local"], button {
							padding: 10px;
							margin: 5px;
							width: 100%;
						}
						</style>
	</head>
	<body>
		<div class="container">
			<h1>Clock In/Out</h1>
			<input type="text" id="qgendaurl" placeholder="Enter Qgenda Calendar URL">
				<input type="text" id="assignmentInput" placeholder="Enter your assignment">
					<input type="datetime-local" id="dateTimeInput">
						<button id="clockInButton" onclick="clockIn()">Clock In</button>
						<button id="clockOutButton" onclick="clockOut()" disabled>Clock Out</button>
						
						<h2>Get Records</h2>
						<input type="datetime-local" id="startDate">
							<input type="datetime-local" id="endDate">
								<button onclick="getRecords()">Get Records</button>
								<button onclick="getLastWeekRecords()">Last Week</button>
								<button onclick="getLastMonthRecords()">Last Month</button>
								<!-- <button onclick="clearIndexedDB()">Clear IndexedDB</button> -->
								</div>
		
		<script>
			const dbName = 'ClockInOutDB';
			const calstoreName = 'calStore'; //calendar related items
			const clockstoreName = 'clockStore'; //Clock In and Out store
			let db;
			
			function initDB() {
				if (navigator.storage && navigator.storage.persist) {
					navigator.storage.persist().then(function(isPersistent) {
													 if (isPersistent) {
													 console.log("Storage is set to persistent.");
													 } else {
													 console.log("Storage is not persistent.");
													 }
													 }).catch(function(error) {
															  console.error("Error requesting persistent storage:", error);
															  });
				} else {
					console.log("Persistent storage is not supported by this browser.");
				}
				const request = indexedDB.open(dbName, 1);
				
				request.onupgradeneeded = function(event) {
					db = event.target.result;
					db.createObjectStore(clockstoreName, { keyPath: 'id', autoIncrement: true });
					
				};
				
				request.onsuccess = function(event) {
					db = event.target.result;
					loadQGendaURL();
				};
				
				request.onerror = function(event) {
					console.error('IndexedDB error:', event.target.errorCode);
				};
			}
		
		function getTransaction(storeName, mode) {
			const transaction = db.transaction([storeName], mode);
			return transaction.objectStore(storeName);
		}
		
		async function saveQGendaURL(url) {
			const store = getTransaction(calstoreName, 'readwrite');
			store.put({ id: 'qgendaurl', value: url });
		}
		
		async function loadQGendaURL() {
			const store = getTransaction(calstoreName, 'readonly');
			const request = store.get('qgendaurl');
			request.onsuccess = function(event) {
				const result = event.target.result;
				if (result) {
					document.getElementById('qgendaurl').value = result.value;
				}
			};
		}
		
		
		async function saveRecord(record) {
			const store = getTransaction(clockstoreName, 'readwrite');
			store.put(record);
		}
		
		function handleURLupdate(){
			const newurl = convertUrlPrefix(document.getElementById('qgendaurl').value);
			document.getElementById('qgendaurl').value=newurl;
			saveQGendaURL(newurl);
			//tell the service worker to delete old calendar and fetch new calendar
				// Send a message to the Service Worker
				if (navigator.serviceWorker.controller) {
					navigator.serviceWorker.controller.postMessage({ type: 'fetch-calendar', data: { url: newurl } });
				}
			
			
			//displayTodaysAssignment();
			
		}
		
		function handleUpdatedAssignment(mynewassignment){
			
			const mydate = document.getElementById('dateTimeInput').value;
			const formattedToday = formatQDate(formatDateTime(mydate));
			storeOrUpdateAssignmentInDB(formattedToday,mynewassignment);
			
		}
		
		function initializeDateTimeInputs() {
			const now = new Date();
			const localDateTime = formatDateTime(now);
			document.getElementById('dateTimeInput').value = localDateTime;
			document.getElementById('startDate').value = localDateTime;
			document.getElementById('endDate').value = localDateTime;
		}
		
		async function getRecords() {
			const startDate = new Date(document.getElementById('startDate').value).toLocaleString();
			const endDate = new Date(document.getElementById('endDate').value).toLocaleString();
			
			const store = getTransaction(clockstoreName, 'readonly');
			const request = store.getAll();
			request.onsuccess = function(event) {
				const records = event.target.result;
				const filteredRecords = records.filter(record => {
													   return record.clockInTime &&
													   record.clockOutTime &&
													   new Date(record.clockInTime) >= new Date(startDate) &&
													   new Date(record.clockOutTime) <= new Date(endDate);
													   });
													   
													   if (filteredRecords.length === 0) {
														   alert('No data exists for the selected time period.');
														   return;
													   }
													   
													   const csvContent = generateCSV(filteredRecords);
													   downloadCSV(csvContent, `records_${formatDate(startDate)}_${formatDate(endDate)}.csv`);
			};
		}
		
		function generateCSV(records) {
			const csvHeaders = ['Assignment', 'Clock-in Time', 'Clock-out Time', 'Time at Work'];
			const csvRows = [csvHeaders.join(',')];
			
			records.forEach(record => {
							const row = [
										 `"${record.assignment}"`,
										 `"${record.clockInTime}"`,
										 `"${record.clockOutTime}"`,
										 `"${calculateTimeAtWork(new Date(record.clockInTime), new Date(record.clockOutTime))}"`
										 ];
							csvRows.push(row.join(','));
							});
							
							return csvRows.join('\n');
		}
		
		function downloadCSV(csvContent, filename) {
			const blob = new Blob([csvContent], { type: 'text/csv' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = filename;
			a.click();
			URL.revokeObjectURL(url);
		}
		
		function calculateTimeAtWork(clockInTime, clockOutTime) {
			const diff = (clockOutTime - clockInTime) / 1000; // difference in seconds
			const hours = Math.floor(diff / 3600);
			const minutes = Math.floor((diff % 3600) / 60);
			return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
		}
		
		function formatDate(date) {
			const d = new Date(date);
			return d.toLocaleDateString().replace(/\//g, '');
												  }
												  
												  function formatDateTime(inputDateTime) {
												  const date = new Date(inputDateTime);
												  const pad = (num, size) => num.toString().padStart(size, '0');
												  const year = date.getFullYear();
												  const month = pad(date.getMonth() + 1, 2);
												  const day = pad(date.getDate(), 2);
												  const hours = pad(date.getHours(), 2);
												  const minutes = pad(date.getMinutes(), 2);
												  const seconds = pad(date.getSeconds(), 2);
												  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
												  }
												  
												  function getLastWeekRecords() {
												  const endDate = new Date();
												  const startDate = new Date();
												  startDate.setDate(endDate.getDate() - 7);
												  document.getElementById('startDate').value = formatDateTime(startDate);
												  document.getElementById('endDate').value = formatDateTime(endDate);
												  getRecords();
												  }
												  
												  function getLastMonthRecords() {
												  const endDate = new Date();
												  const startDate = new Date();
												  startDate.setMonth(endDate.getMonth() - 1);
												  document.getElementById('startDate').value = formatDateTime(startDate);
												  document.getElementById('endDate').value = formatDateTime(endDate);
												  getRecords();
												  }
												  
												  function clearIndexedDB() {
												  const request = indexedDB.deleteDatabase(dbName);
												  request.onsuccess = function() {
												  alert('IndexedDB cleared.');
												  initDB();
												  };
												  request.onerror = function(event) {
												  console.error('IndexedDB clear error:', event.target.errorCode);
												  };
												  }
												  
												  async function clockIn() {
												  const assignment = document.getElementById('assignmentInput').value;
												  const dateTime = document.getElementById('dateTimeInput').value;
												  
												  if (assignment && dateTime) {
												  await saveRecord({
																   clockInTime: new Date(dateTime).toLocaleString(),
																   assignment: assignment,
																   clockOutTime: null,
																   });
												  
												  
												  document.getElementById('clockInButton').disabled = true;
												  document.getElementById('clockOutButton').disabled = false;
												  } else {
												  alert('Please enter your assignment and select a date/time.');
												  }
												  }
												  
												  async function clockOut() {
												  const dateTime = document.getElementById('dateTimeInput').value;
												  
												  if (dateTime) {
												  const store = getTransaction(clockstoreName, 'readwrite');
												  const request = store.openCursor(null, 'prev');
												  request.onsuccess = async function(event) {
												  const cursor = event.target.result;
												  if (cursor) {
												  if (cursor.value.clockOutTime === null) {
												  cursor.update({
																...cursor.value,
																clockOutTime: new Date(dateTime).toLocaleString()
																});
												  
												  
												  document.getElementById('clockInButton').disabled = false;
												  document.getElementById('clockOutButton').disabled = true;
												  } else {
												  alert('No matching clock-in record found.');
												  }
												  } else {
												  alert('No clock-in record found.');
												  }
												  };
												  request.onerror = function(event) {
												  console.error('Cursor error:', event.target.errorCode);
												  };
												  } else {
												  alert('Please select a date/time.');
												  }
												  }
												  
												  async function displayTodaysAssignment() {
												  const mydate = document.getElementById('dateTimeInput').value;
												  const formattedToday = formatQDate(formatDateTime(mydate));
												  
												  try {
												  // Check if today's assignment is already in the IndexedDB
												  const todayAssignment = await getAssignmentFromDB(formattedToday);
												  
												  if (todayAssignment) {
												  // Assignment for today exists in IndexedDB
												  document.getElementById('assignmentInput').value = todayAssignment.assignment;
												  } else {
												 //Assignment for the date not in Database
												  }
												  } catch (error) {
												  console.error('Error displaying today\'s assignment:', error);
												  }
												  }
												  
												  // Function to get an assignment from IndexedDB
												  function getAssignmentFromDB(date) {
												  return new Promise((resolve, reject) => {
																	 const store = getTransaction(calstoreName, 'readonly');
																	 const request = store.get(date);
																	 
																	 request.onsuccess = function(event) {
																	 resolve(event.target.result);
																	 };
																	 
																	 request.onerror = function(event) {
																	 reject(event.target.error);
																	 };
																	 });
												  }
												  
												  // Function to store or update assignment in IndexedDB
												  function storeOrUpdateAssignmentInDB(date, summary) {
												  return new Promise((resolve, reject) => {
																	 const store = getTransaction(calstoreName, 'readwrite');
																	 const request = store.get(date);
																	 
																	 request.onsuccess = function(event) {
																	 const result = event.target.result;
																	 if (result) {
																	 // Concatenate new summary with existing assignment
																	 const updatedAssignment = `${result.assignment} ${summary}`;
																	 store.put({ id: date, date: date, assignment: updatedAssignment });
																	 } else {
																	 // Store new assignment
																	 store.put({ id: date, date: date, assignment: summary });
																	 }
																	 resolve();
																	 };
																	 
																	 request.onerror = function(event) {
																	 reject(event.target.error);
																	 };
																	 });
												  }
												  
												  // Utility functions (unchanged)
												  function parseCustomDate(dateString) {
												  const year = dateString.slice(0, 4);
												  const month = dateString.slice(4, 6) - 1; // Months are 0-indexed in JavaScript
												  const day = dateString.slice(6, 8);
												  
												  return new Date(year, month, day);
												  }
												  
												  function formatQDate(date) {
												  return date.split('T')[0];
												  }
												  
												  function parseICalendar(data) {
												  const events = [];
												  const lines = data.split('\n');
												  let event = null;
												  
												  for (const line of lines) {
												  if (line.startsWith('BEGIN:VEVENT')) {
												  event = { details: {} };
												  } else if (line.startsWith('SUMMARY:')) {
												  event.details.summary = line.replace('SUMMARY:', '');
												  } else if (line.startsWith('DTSTART;VALUE=DATE:')) {
												  event.details.start = line.replace('DTSTART;VALUE=DATE:', '');
												  } else if (line.startsWith('DTEND;VALUE=DATE:')) {
												  event.details.end = line.replace('DTEND;VALUE=DATE:', '');
												  } else if (line.startsWith('END:VEVENT')) {
												  if (event) {
												  events.push(event);
												  event = null;
												  }
												  }
												  }
												  return events;
												  }
												  
												 

												 
												  
												  function convertUrlPrefix(url) {
												  const oldPrefix = "https://app.qgenda.com/ical";
												  const newPrefix = "/clock/qgenda/ical";
												  
												  // Replace the old prefix with the new prefix
												  if (url.startsWith(oldPrefix)) {
												  return url.replace(oldPrefix, newPrefix);
												  } else {
												  return url; // Return the original URL if it doesn't match the old prefix
												  }
												  }
												  
												  initDB();
												  
												  
												  //displayTodaysAssignment();
												  
												  window.onload = initializeDateTimeInputs;
												  
												  document.getElementById('qgendaurl').addEventListener('blur', function() {
																										const url = this.value;
																										if (url) {
																										handleURLupdate(url);
																										}
																										});
												  
												  
												  
												  function debounce(func, delay) {
												  let timeout;
												  return function(...args) {
												  clearTimeout(timeout);
												  timeout = setTimeout(() => func.apply(this, args), delay);
												  };
												  }
												  
											document.getElementById('assignmentInput').addEventListener('input', debounce(function() {
																														  const url = this.value;
																														  if (url) {
																														  handleUpdatedAssignment(url);
																														  }													  }, 500)); // Adjust the delay as needed
												  
												  document.getElementById('dateTimeInput').addEventListener('change', function() {
																											  const url = this.value;
																											  if (url) {
																											displayTodaysAssignment();
																											  }
																											  });
												  function handleDateUpdate(event) {
												  const selectedDate = event.target.value;
												  if (selectedDate) {
												  // Your logic here
												  console.log('User selected date:', selectedDate);
												  }
												  }
												  // Service Worker registration
												  if ('serviceWorker' in navigator) {
												  window.addEventListener('load', function() {
																		  navigator.serviceWorker.register('./service-worker.js').then(function(registration) {
																																	   console.log('ServiceWorker registration successful with scope: ', registration.scope);
																																	   }).catch(function(error) {
																																				console.log('ServiceWorker registration failed: ', error);
																																				});
																		  });
												  }
												  </script>
	</body>
</html>

