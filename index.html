<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clock In/Out Tracker</title>
<link rel="manifest" href="./manifest.json">
<link rel="icon" href="./icons/favicon.ico" type="image/x-icon">
<style>
body {
	font-family: Arial, sans-serif;
margin: 50px;
}

.container {
	max-width: 300px;
margin: auto;
	text-align: center;
}

input[type="text"], input[type="datetime-local"], button {
padding: 10px;
margin: 5px;
width: 100%;
}
</style>
</head>
<body>
<div class="container">
<h1>Clock In/Out</h1>
<input type="text" id="qgendaurl" placeholder="Enter Qgenda Calendar URL">
<input type="datetime-local" id="dateTimeInput">
<input type="hidden" id="assignmentInput" placeholder="Enter your assignment">
<input type="text" id="storedassignmentInput" placeholder="Enter your assignment">
<table id = "mytable"></table>
<input type="datetime-local" id="ClockInTimeInput">
<button id="clockInButton" onclick="clockIn()">Clock In</button>
<input type="datetime-local" id="ClockOutTimeInput">
<button id="clockOutButton" onclick="clockOut()">Clock Out</button>
<h2>Get Records</h2>
<input type="datetime-local" id="startDate">
<input type="datetime-local" id="endDate">
<button onclick="getRecords()">Get Records</button>
<button onclick="getLastWeekRecords()">Last Week</button>
<button onclick="getLastMonthRecords()">Last Month</button>
<!-- <button onclick="clearIndexedDB()">Clear IndexedDB</button> -->
</div>
<script>
const dbName = 'ClockInOutDB';
const calstoreName = 'calStore';
	//calendar related items
const clockstoreName = 'clockStore';
	//Clock In and Out store
let db;

function initDB(callback) {
	if (navigator.storage && navigator.storage.persist) {
		navigator.storage.persist().then(function(isPersistent) {
										 if (isPersistent) {
										 console.log("Storage is set to persistent.");
										 } else {
										 console.log("Storage is not persistent.");
										 }
										 }).catch(function(error) {
												  console.error("Error requesting persistent storage:", error);
												  });
	} else {
		console.log("Persistent storage is not supported by this browser.");
	}
	
	const request = indexedDB.open(dbName, 2);
	
	request.onupgradeneeded = function(event) {
		db = event.target.result;
		
		let clockStore;
		if (!db.objectStoreNames.contains(clockstoreName)) {
			clockStore = db.createObjectStore(clockstoreName, {
											  keyPath: 'id',
											  autoIncrement: true
											  });
		} else {
			clockStore = request.transaction.objectStore(clockstoreName);
		}
		
			// Add the index on date and assignment
		if (!clockStore.indexNames.contains('date_index')) {
			
			clockStore.createIndex('date_index', ['date'], {
								   unique: false
								   })
		}
		
		if (!db.objectStoreNames.contains(calstoreName)) {
			db.createObjectStore(calstoreName, {
								 keyPath: 'id',
								 autoIncrement: true
								 });
		}
		
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'database-ready'
																		   });
										   });
	}
	;
	
	request.onsuccess = function(event) {
		db = event.target.result;
		if (callback)
			callback();
		loadQGendaURL();
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'database-ready'
																		   });
										   });
	}
	;
	
	request.onerror = function(event) {
		console.error('IndexedDB error:', event.target.errorCode);
	}
	;
}

function getTransaction(storeName, mode) {
		//Check if dB is ready or initialized.
	if (db && db.objectStoreNames.contains([storeName])) {
		const transaction = db.transaction([storeName], mode);
		return transaction.objectStore(storeName);
	} else {
		console.log("getTransaction -db not ready or doesn't have requested store = " + storeName);
	}
}

async function saveQGendaURL(url) {
	const store = getTransaction(calstoreName, 'readwrite');
	store.put({
			  id: 'qgendaurl',
			  value: url
			  });
}

async function loadQGendaURL() {
	const store = getTransaction(calstoreName, 'readonly');
	const request = store.get('qgendaurl');
	request.onsuccess = function(event) {
		const result = event.target.result;
		if (result) {
			document.getElementById('qgendaurl').value = result.value;
		}
	}
	;
}

async function saveRecord(record) {
	const store = getTransaction(clockstoreName, 'readwrite');
	store.put(record);
}

function handleURLupdate() {
	const newurl = convertUrlPrefix(document.getElementById('qgendaurl').value);
	document.getElementById('qgendaurl').value = newurl;
	saveQGendaURL(newurl);
	
	if ('serviceWorker'in navigator) {
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'fetch-calendar',
																		   data: {
																		   url: newurl
																		   }
																		   });
										   }).catch(error=>{
													console.error('Service Worker registration error:', error);
													}
													);
		
			// Listen for messages from the service worker
		navigator.serviceWorker.addEventListener('message', function(event) {
												 if (event.data.type === 'fetch-complete') {
												 if (event.data.status === 'success') {
												 console.log('Fetch complete, data is ready');
												 // Handle the successful fetch
												 displayTodaysAssignment();
												 } else if (event.data.status === 'error') {
												 console.error('Fetch failed:', event.data.error);
												 // Handle the error
												 }
												 }
												 });
	}
	
}

function handleUpdatedAssignment(mynewassignment) {
	
	const mydate = document.getElementById('dateTimeInput').value;
	const formattedToday = formatQDate(formatDateTime(mydate));
		//Leave the Qgenda calendar alone. Handle updated assignments in clockstore
		//updateAssignmentInDB(formattedToday,mynewassignment);
	
}

function initializeDateTimeInputs(callback) {
	const now = new Date();
	const localDateTime = formatDateTime(now);
	document.getElementById('dateTimeInput').value = localDateTime;
	document.getElementById('startDate').value = localDateTime;
	document.getElementById('endDate').value = localDateTime;
	document.getElementById('ClockOutTimeInput').value = localDateTime;
	document.getElementById('ClockInTimeInput').value = localDateTime;
	
		// Check if assignment exists in the DB
	if (callback)
		callback();
}

async function getRecords() {
	const startDate = new Date(document.getElementById('startDate').value).toLocaleString();
	const endDate = new Date(document.getElementById('endDate').value).toLocaleString();
	
	const store = getTransaction(clockstoreName, 'readonly');
	const request = store.getAll();
	request.onsuccess = function(event) {
		const records = event.target.result;
		const filteredRecords = records.filter(record=>{
											   return record.clockInTime && record.clockOutTime && new Date(record.clockInTime) >= new Date(startDate) && new Date(record.clockOutTime) <= new Date(endDate);
											   }
											   );
		
		if (filteredRecords.length === 0) {
			alert('No data exists for the selected time period.');
			return;
		}
		
		const csvContent = generateCSV(filteredRecords);
		downloadCSV(csvContent, `records_ ${formatDate(startDate)}_ ${formatDate(endDate)}.csv`);
	}
	;
}

function generateCSV(records) {
	const csvHeaders = ['Assignment', 'Clock-in Time', 'Clock-out Time', 'Time at Work'];
	const csvRows = [csvHeaders.join(',')];
	
	records.forEach(record=>{
					const row = [`"${record.assignment}"`, `"${record.clockInTime}"`, `"${record.clockOutTime}"`, `"${calculateTimeAtWork(new Date(record.clockInTime), new Date(record.clockOutTime))}"`];
					csvRows.push(row.join(','));
					}
					);
	
	return csvRows.join('\n');
}

function downloadCSV(csvContent, filename) {
	const blob = new Blob([csvContent],{
						  type: 'text/csv'
						  });
	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	a.download = filename;
	a.click();
	URL.revokeObjectURL(url);
}

function calculateTimeAtWork(clockInTime, clockOutTime) {
	const diff = (clockOutTime - clockInTime) / 1000;
		// difference in seconds
	const hours = Math.floor(diff / 3600);
	const minutes = Math.floor((diff % 3600) / 60);
	return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}

function formatDate(date) {
	const d = new Date(date);
	return d.toLocaleDateString().replace(/\//g, '');
										  }
										  
										  function formatDateTime(inputDateTime) {
										  const date = new Date(inputDateTime);
										  const pad = (num, size) => num.toString().padStart(size, '0');
										  const year = date.getFullYear();
										  const month = pad(date.getMonth() + 1, 2);
										  const day = pad(date.getDate(), 2);
										  const hours = pad(date.getHours(), 2);
										  const minutes = pad(date.getMinutes(), 2);
										  const seconds = pad(date.getSeconds(), 2);
										  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
										  }
										  
										  
										  function getLastWeekRecords() {
										  const endDate = new Date();
										  const startDate = new Date();
										  startDate.setDate(endDate.getDate() - 7);
										  document.getElementById('startDate').value = formatDateTime(startDate);
										  document.getElementById('endDate').value = formatDateTime(endDate);
										  getRecords();
										  }
										  
										  function getLastMonthRecords() {
										  const endDate = new Date();
										  const startDate = new Date();
										  startDate.setMonth(endDate.getMonth() - 1);
										  document.getElementById('startDate').value = formatDateTime(startDate);
										  document.getElementById('endDate').value = formatDateTime(endDate);
										  getRecords();
										  }
										  
										  function clearIndexedDB() {
										  const request = indexedDB.deleteDatabase(dbName);
										  request.onsuccess = function() {
										  alert('IndexedDB cleared.');
										  initDB();
										  }
										  ;
										  request.onerror = function(event) {
										  console.error('IndexedDB clear error:', event.target.errorCode);
										  }
										  ;
										  }
										  
										  function getAssignmentsByDate(date) {
										  const store = getTransaction(clockstoreName, 'readonly');
										  const index = store.index('date_index');
										  // Assumes you have an index on date and assignment
										  
										  const query = IDBKeyRange.only([date]);
										  const request = index.getAll(query);
										  
										  return new Promise((resolve,reject)=>{
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 }
															 ;
															 request.onerror = function(event) {
															 reject('Failed to retrieve assignment');
															 }
															 ;
															 }
															 );
										  }
										  
										  // Example usage:
										  /*
										   getAssignmentByDateAndSummary('2024-08-29', 'Morning Shift').then((result) => {
										   if (result) {
										   console.log('Assignment found:', result);
										   } else {
										   console.log('Assignment not found');
										   }
										   }).catch((error) => {
										   console.error(error);
										   });
										   
										   
										   */
										  
										  async function editTimes(primaryKey, whichTime) {
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  // Create a temporary input element for date-time selection
										  const dateTimeInput = document.createElement('input');
										  dateTimeInput.type = 'datetime-local';
										  document.body.appendChild(dateTimeInput);
										  
										  // Set the value to the current time if there is already a value
										  const store = getTransaction(clockstoreName, 'readonly');
										  const request = store.get(primaryKey);
										  
										  request.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Set the default value of the date-time picker to the current time
										  if (whichTime === 'clockIn') {
										  dateTimeInput.value = record.clockInTime || localDateTime;
										  } else if (whichTime === 'clockOut') {
										  dateTimeInput.value = record.clockOutTime || localDateTime;
										  }
										  
										  // Open the date-time picker
										  dateTimeInput.focus();
										  
										  dateTimeInput.onchange = async function() {
										  const selectedDateTime = dateTimeInput.value;
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const updateRequest = store.get(primaryKey);
										  
										  updateRequest.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record based on whichTime
										  if (whichTime === 'clockIn') {
										  record.clockInTime = selectedDateTime;
										  } else if (whichTime === 'clockOut') {
										  record.clockOutTime = selectedDateTime;
										  }
										  
										  // Save the updated record back into the object store
										  const updateRequest = store.put(record);
										  updateRequest.onsuccess = function() {
										  // Update the displayed value in the corresponding cell
										  const cellId = whichTime === 'clockIn' ? 'clockIn' + primaryKey : 'clockOut' + primaryKey;
										  const cell = document.getElementById(cellId);
										  if (cell) {
										  cell.textContent = selectedDateTime + " ";
										  const editButton = document.createElement("button");
										  editButton.textContent = "Edit";
										  editButton.onclick = () => editTimes(primaryKey, whichTime); // Refresh the edit button
										  cell.appendChild(editButton);
										  }
										  };
										  updateRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.error);
										  };
										  }
										  };
										  updateRequest.onerror = function(event) {
										  console.error('Error retrieving record:', event.target.error);
										  };
										  
										  // Remove the date-time input element
										  document.body.removeChild(dateTimeInput);
										  };
										  
										  dateTimeInput.onblur = function() {
										  // Remove the date-time input element if the user clicks outside
										  document.body.removeChild(dateTimeInput);
										  };
										  }
										  };
										  request.onerror = function(event) {
										  console.error('Error retrieving record:', event.target.error);
										  };
										  }

										  async function clockIn(primaryKey) {
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const request = store.get(primaryKey);
										  
										  request.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record with clockInTime
										  record.clockInTime = localDateTime; // Current time
										  
										  // Save the updated record back into the object store
										  const updateRequest = store.put(record);
										  
										  updateRequest.onsuccess = function(event) {
										  // Update the UI after successful clock in
										  const clockInCell = document.getElementById('clockIn' + primaryKey);
										  clockInCell.textContent = localDateTime + " ";
										  
										  // Add the Edit button next to the clockIn time
										  const editButton = document.createElement("button");
										  editButton.textContent = "Edit";
										  editButton.onclick = () => editTimes(primaryKey, "clockIn"); // Pass the id to editTimes
										  clockInCell.appendChild(editButton);
										  };
										  
										  updateRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.errorCode);
										  };
										  } else {
										  console.log('Record not found');
										  }
										  };
										  
										  request.onerror = function(event) {
										  console.log('Failed to retrieve assignment');
										  const assignment = document.getElementById('storedassignmentInput').value;
										  const dateTime = document.getElementById('dateTimeInput').value;
										  
										  const formattedToday = formatQDate(formatDateTime(dateTime)); // Date of interest
										  
										  if (assignment && dateTime) {
										  const store = getTransaction(clockstoreName, 'readwrite');
										  store.put({
													date: formattedToday,
													clockInTime: document.getElementById('ClockInTimeInput').value, // Add clockInTime
													assignment: assignment,
													clockOutTime: null, // Leave clockOutTime as null
													});
										  document.getElementById('clockInButton').innerHTML = "Clocked In";
										  document.getElementById('clockInButton').disabled = true;
										  } else {
										  alert('Please enter your assignment and select a date/time.');
										  }
										  };
										  }

										  
										  async function clockOut(primaryKey) {
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const request = store.get(primaryKey);
										  
										  request.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record with clockOutTime
										  record.clockOutTime = localDateTime; // Current time
										  
										  // Save the updated record back into the object store
										  const updateRequest = store.put(record);
										  
										  updateRequest.onsuccess = function(event) {
										  // Update the UI after successful clock out
										  const clockOutCell = document.getElementById('clockOut' + primaryKey);
										  clockOutCell.textContent = localDateTime + " ";
										  
										  // Add the Edit button next to the clockOut time
										  const editButton = document.createElement("button");
										  editButton.textContent = "Edit";
										  editButton.onclick = () => editTimes(primaryKey, "clockOut"); // Pass the id to editTimes
										  clockOutCell.appendChild(editButton);
										  };
										  
										  updateRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.errorCode);
										  };
										  } else {
										  console.log('Record not found');
										  }
										  };
										  
										  request.onerror = function(event) {
										  console.log('Failed to retrieve assignment');
										  const assignment = document.getElementById('storedassignmentInput').value;
										  const dateTime = document.getElementById('dateTimeInput').value;
										  
										  const formattedToday = formatQDate(formatDateTime(dateTime)); // Date of interest
										  
										  if (assignment && dateTime) {
										  const store = getTransaction(clockstoreName, 'readwrite');
										  store.put({
													date: formattedToday,
													clockInTime: null,
													assignment: assignment,
													clockOutTime: document.getElementById('ClockOutTimeInput').value,
													});
										  document.getElementById('clockOutButton').innerHTML = "Clocked Out";
										  document.getElementById('clockOutButton').disabled = true;
										  } else {
										  alert('Please enter your assignment and select a date/time.');
										  }
										  };
										  }

										  
										  async function displayTodaysAssignment() {
										  // Clear and reset the clock in/clock out times and buttons
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  
										  // Reset clockIn, clockOut times and buttons
										  document.getElementById('ClockOutTimeInput').value = localDateTime;
										  document.getElementById('ClockInTimeInput').value = localDateTime;
										  document.getElementById('clockInButton').innerHTML = "Clock In";
										  document.getElementById('clockOutButton').innerHTML = "Clock Out";
										  document.getElementById('storedassignmentInput').value = null;
										  
										  // Get today's date input value
										  const mydate = document.getElementById('dateTimeInput').value;
										  const formattedToday = formatQDate(formatDateTime(mydate));
										  
										  try {
										  // Check if today's assignment is already in the IndexedDB
										  const todayAssignment = await getAssignmentFromDB(formattedToday);
										  
										  if (todayAssignment) {
										  // Assignment for today exists in IndexedDB
										  document.getElementById('assignmentInput').value = todayAssignment.assignment; 
										  document.getElementById('storedassignmentInput').value = todayAssignment.assignment;
										  }
										  
										  // Get assignments for today and update the table
										  const result = await getAssignmentsByDate(formattedToday);
										  const mytable = document.getElementById("mytable");
										  mytable.textContent = ""; // Clear existing table contents
										  
										  if (result) {
										  result.forEach(function (individualresult) {
														 console.log(individualresult);
														 
														 // Create a new row
														 const myrow = document.createElement("tr");
														 myrow.id = `row${individualresult.id}`;
														 // Append other details like id, date, assignment
														 for (const cell of [
																			 individualresult.id,
																			 individualresult.date,
																			 individualresult.assignment
																			 ]) {
														 const tableCell = document.createElement("td");
														 tableCell.textContent = cell;
														 myrow.appendChild(tableCell);
														 }
														 
														 // Clock In Time Cell
														 const clockInCell = document.createElement("td");
														 clockInCell.id = "clockIn" + individualresult.id; // Add unique ID
														 
														 if (individualresult.clockInTime) {
														 // If clockInTime exists, display it and add an Edit button
														 clockInCell.textContent = individualresult.clockInTime + " ";
														 const editButton = document.createElement("button");
														 editButton.textContent = "Edit";
														 editButton.onclick = () => editTimes(individualresult.id, "clockIn"); // Pass the id to editTimes
														 clockInCell.appendChild(editButton);
														 } else {
														 // If clockInTime is null, add a Clock In button
														 const clockInButton = document.createElement("button");
														 clockInButton.textContent = "Clock In";
														 clockInButton.onclick = () => clockIn(individualresult.id); // Pass the id to clockIn
														 clockInCell.appendChild(clockInButton);
														 }
														 myrow.appendChild(clockInCell);
														 
														 // Clock Out Time Cell
														 const clockOutCell = document.createElement("td");
														 clockOutCell.id = "clockOut" + individualresult.id; // Add unique ID
														 
														 if (individualresult.clockOutTime) {
														 // If clockOutTime exists, display it and add an Edit button
														 clockOutCell.textContent = individualresult.clockOutTime + " ";
														 const editButton = document.createElement("button");
														 editButton.textContent = "Edit";
														 editButton.onclick = () => editTimes(individualresult.id,"clockOut"); // Pass the id to editTimes
														 clockOutCell.appendChild(editButton);
														 } else {
														 // If clockOutTime is null, add a Clock Out button
														 const clockOutButton = document.createElement("button");
														 clockOutButton.textContent = "Clock Out";
														 clockOutButton.onclick = () => clockOut(individualresult.id); // Pass the id to clockOut
														 clockOutCell.appendChild(clockOutButton);
														 }
														 myrow.appendChild(clockOutCell);
														 
														 // Delete Button Cell
														 const deleteCell = document.createElement("td");
														 const deleteButton = document.createElement("button");
														 deleteButton.textContent = "Delete";
														 deleteButton.onclick = () => deleteRecord(individualresult.id); // Pass the id to deleteRecord
														 deleteCell.appendChild(deleteButton);
														 myrow.appendChild(deleteCell);
														 
														 // Append the row to the table
														 mytable.appendChild(myrow);
														 });
										  } else {
										  console.log("No assignments found for today.");
										  }
										  } catch (error) {
										  console.error('Error displaying today\'s assignment:', error);
										  }
										  }

										  async function deleteRecord(primaryKey) {
										  const store = getTransaction(clockstoreName, 'readwrite'); // Open a readwrite transaction
										  const request = store.delete(primaryKey); // Delete the record with the given primary key
										  
										  request.onsuccess = function(event) {
										  console.log(`Record with primaryKey ${primaryKey} deleted successfully!`);
										  
										  // Remove the corresponding row from the UI
										  const rowToDelete = document.getElementById(`row${primaryKey}`);
										  if (rowToDelete) {
										  rowToDelete.remove(); // Remove the row from the table
										  }
										  };
										  
										  request.onerror = function(event) {
										  console.error('Error deleting record:', event.target.errorCode);
										  };
										  }

										  
										  
										  function getRecordsByDate(date, callback) {
										  const store = getTransaction(clockstoreName, 'readonly');
										  const index = store.index('date_index');
										 
										  // Query by date
										  
										  const keyRange = IDBKeyRange.only([date]);
										  
										  //const request = index.openKeyCursor(keyRange);
										  const request = index.getAll(keyRange);
										  request.onsuccess = function(event) {
										  const records = event.target.result; console.log(records);
										  if (records) { callback(records);} else {console.log ("No records");}
										  // Handle the array of records
										  }
										  ;
										  
										  request.onerror = function(event) {
										  console.error('Error fetching records by date:', event.target.errorCode);
										  }
										  ;
										  }

										  
										  // Function to get an assignment from IndexedDB
										  function getAssignmentFromDB(date) {
										  return new Promise((resolve,reject)=>{
															 const store = getTransaction(calstoreName, 'readonly');
															 const request = store.get(date);
															 
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 }
															 ;
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 }
															 ;
															 }
															 );
										  }
										  
										  // Function to update assignment in IndexedDB
										  function updateAssignmentInDB(date, summary) {
										  return new Promise((resolve,reject)=>{
															 const store = getTransaction(calstoreName, 'readwrite');
															 const request = store.get(date);
															 
															 request.onsuccess = function(event) {
															 const result = event.target.result;
															 if (result) {
															 // Replace the existing assignment with the new summary
															 store.put({
																	   id: date,
																	   date: date,
																	   assignment: summary
																	   });
															 } else {
															 // Store new assignment
															 store.put({
																	   id: date,
																	   date: date,
																	   assignment: summary
																	   });
															 }
															 resolve();
															 }
															 ;
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 }
															 ;
															 }
															 );
										  }
										  
										  // Utility functions (unchanged)
										  function parseCustomDate(dateString) {
										  const year = dateString.slice(0, 4);
										  const month = dateString.slice(4, 6) - 1;
										  // Months are 0-indexed in JavaScript
										  const day = dateString.slice(6, 8);
										  
										  return new Date(year,month,day);
										  }
										  
										  function formatQDate(date) {
										  return date.split('T')[0];
										  }
										  
										  function parseICalendar(data) {
										  const events = [];
										  const lines = data.split('\n');
										  let event = null;
										  
										  for (const line of lines) {
										  if (line.startsWith('BEGIN:VEVENT')) {
										  event = {
										  details: {}
										  };
										  } else if (line.startsWith('SUMMARY:')) {
										  event.details.summary = line.replace('SUMMARY:', '');
										  } else if (line.startsWith('DTSTART;VALUE=DATE:')) {
										  event.details.start = line.replace('DTSTART;VALUE=DATE:', '');
										  } else if (line.startsWith('DTEND;VALUE=DATE:')) {
										  event.details.end = line.replace('DTEND;VALUE=DATE:', '');
										  } else if (line.startsWith('END:VEVENT')) {
										  if (event) {
										  events.push(event);
										  event = null;
										  }
										  }
										  }
										  return events;
										  }
										  
										  function convertUrlPrefix(url) {
										  const oldPrefix = "https://app.qgenda.com/ical";
										  const newPrefix = "/clock/qgenda/ical";
										  
										  // Replace the old prefix with the new prefix
										  if (url.startsWith(oldPrefix)) {
										  return url.replace(oldPrefix, newPrefix);
										  } else {
										  return url;
										  // Return the original URL if it doesn't match the old prefix
										  }
										  }
										  
										  function checkAndDisplayAssignment() {
										  if (db && db.objectStoreNames.contains(calstoreName)) {
										  displayTodaysAssignment();
										  } else {
										  console.error('Database not initialized or calstoreName does not exist.');
										  }
										  }
										  
										  // Ensure proper sequencing
										  window.onload = function() {
										  initDB(function() {
												 initializeDateTimeInputs(function() {
																		  checkAndDisplayAssignment();
																		  });
												 });
										  }
										  ;
										  
										  document.getElementById('qgendaurl').addEventListener('blur', function() {
																								const url = this.value;
																								if (url) {
																								handleURLupdate(url);
																								}
																								});
										  
										  function debounce(func, delay) {
										  let timeout;
										  return function(...args) {
										  clearTimeout(timeout);
										  timeout = setTimeout(()=>func.apply(this, args), delay);
										  }
										  ;
										  }
										  
										  document.getElementById('assignmentInput').addEventListener('input', debounce(function() {
																														const url = this.value;
																														if (url) {
																														handleUpdatedAssignment(url);
																														}
																														}, 500));
										  // Adjust the delay as needed
										  
										  document.getElementById('dateTimeInput').addEventListener('change', function() {
																									const url = this.value;
																									if (url) {
																									displayTodaysAssignment();
																									}
																									});
										  
										  window.addEventListener('focus', function() {
																  //console.log('Window is back in focus');
																  initializeDateTimeInputs(function() {
																						   checkAndDisplayAssignment();
																						   });
																  
																  });
										  
										  function handleDateUpdate(event) {
										  const selectedDate = event.target.value;
										  if (selectedDate) {
										  // Your logic here
										  console.log('User selected date:', selectedDate);
										  }
										  }
										  // Service Worker registration
										  if ('serviceWorker'in navigator) {
										  window.addEventListener('load', function() {
																  navigator.serviceWorker.register('./service-worker.js').then(function(registration) {
																															   console.log('ServiceWorker registration successful with scope: ', registration.scope);
																															   }).catch(function(error) {
																																		console.log('ServiceWorker registration failed: ', error);
																																		});
																  });
										  }
										  </script>
										  </body>
										  </html>
										  
