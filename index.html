<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clock In/Out Tracker</title>
<link rel="manifest" href="./manifest.json">
<link rel="icon" href="./icons/favicon.ico" type="image/x-icon">
<style>
	//* General Styling */
* {
	box-sizing: border-box;
margin: 0;
padding: 0;
}

body {
	font-family: 'Arial', sans-serif;
	background-color: #f4f4f4;
margin: 0;
padding: 20px;
	-webkit-font-smoothing: antialiased;
color: #333;
}

.container {
	max-width: 400px;
margin: 50px auto;
padding: 20px;
	background-color: #fff;
	border-radius: 8px;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
	text-align: center;
}

h1, h2 {
	margin-bottom: 20px;
color: #2c3e50;
}

/* Inputs & Buttons */
input[type="text"], input[type="datetime-local"], input[type="date"]{
width: min-content;
padding: 12px;
margin: 10px 0;
border: 1px solid #ccc;
	border-radius: 5px;
	font-size: 16px;
transition: all 0.3s ease;
}

input[type="text"]:focus, input[type="datetime-local"]:focus, input[type="date"]:focus {
	border-color: #3498db;
outline: none;
}

button {
	background-color: #3498db;
color: #fff;
border: none;
cursor: pointer;
	font-size: 16px;
transition: background-color 0.3s ease;
}

button:hover {
	background-color: #2980b9;
}

/* Table Styling */
#mytable {
//width: 100%;
	margin-top: 20px;
	border-collapse: collapse;
	table-layout: fixed; /* Prevent horizontal overflow */
	overflow-x: auto; /* Allow scrolling if necessary */
}

#mytable th, #mytable td {
padding: 8px;
	text-align: left;
	border-bottom: 1px solid #ddd;
	word-wrap: break-word; /* Force wrapping in long content */
	font-size: 14px; /* Adjust the font size for better fit */
	white-space: normal; /* Allow text to wrap */
}

#mytable th {
	background-color: #f4f4f4;
color: #333;
}

#mytable tr:hover {
	background-color: #f9f9f9;
}

/* Mobile Styles */
@media only screen and (max-width: 600px) {
	body {
	padding: 10px;
	}
	
	.container {
	margin: 30px auto;
	padding: 15px;
	}
	
	input[type="text"], input[type="datetime-local"], input[type="date"], button {
		font-size: 14px;
	padding: 10px;
	}
	
	h1, h2 {
		font-size: 20px;
	}
	
	#mytable th, #mytable td {
		//font-size: 12px; /* Reduce the font size on smaller screens */
	}
}

/* Modal Styling */
#dateTimeModal {
display: none;
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: white;
	border-radius: 8px;
padding: 20px;
	box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
	z-index: 1000;
width: 80%;
	max-width: 400px;
}

#dateTimeModal label {
display: block;
	margin-bottom: 10px;
	font-size: 16px;
color: #2c3e50;
}

#dateTimeModal button {
width: 100%;
	margin-top: 10px;
}
.icon {
width: 24px;
height: 24px;
cursor: pointer;
color: #333;
}

.icon:hover {
color: #007bff;
}
</style>
</head>
<body>
<div class="container">
<h1>Clock In/Out</h1>

<!-- Label and Input for Qgenda URL -->
<label for="qgendaurl">Qgenda Calendar URL:</label>
<input type="text" id="qgendaurl" placeholder="Enter Qgenda Calendar URL"> 
<!-- SVG for Sync (Recycle) Button -->
<svg class="icon" onclick="handleURLupdate()" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24px" height="24px">
<path d="M21 11.5a8.38 8.38 0 01-3.5 6.88m-2 .61A8.5 8.5 0 013.5 12H1m0 0l3-3m-3 3l3 3" />
<path d="M3 12.5a8.38 8.38 0 013.5-6.88m2-.61A8.5 8.5 0 0120.5 12H23m0 0l-3 3m3-3l-3-3" />
</svg>


<br>
<!-- Label and Input for Date -->
<label for="dateTimeInput">Select Date:</label>
<input type="date" id="dateTimeInput">
<br>

<!-- Label and Input for Assignment (Hidden Input) -->
<input type="hidden" id="assignmentInput">

<!-- Label and Input for Stored Assignment -->
<label for="storedassignmentInput">Assignment:</label>
<input type="text" id="storedassignmentInput0" placeholder="Enter your assignment">
<table id="mytable"></table>
<!-- Clock In/Out Section -->
<div id="clockInOut">
<label for="ClockInTimeInput">Clock In Time:</label><br>
<input type="datetime-local" id="ClockInTimeInput">
<button id="clockInButton" onclick="clockIn('0')">Clock In</button><br>

<label for="ClockOutTimeInput">Clock Out Time:</label><br>
<input type="datetime-local" id="ClockOutTimeInput">
<button id="clockOutButton" onclick="clockOut('0')">Clock Out</button><br>
</div>

<!-- Section for Getting Records -->
<h2>Get Records</h2>
<label for="startDate">From:</label>
<input type="date" id="startDate"><br>

<label for="endDate">To:</label>
<input type="date" id="endDate">
<button onclick="getRecords()">Get Records</button>
<button onclick="getLastWeekRecords()">Last Week</button>
<button onclick="getLastMonthRecords()">Last Month</button>
</div>

<!-- Modal -->
<div id="dateTimeModal">
<label for="dateTimeInputModal">Enter date and time:</label>
<input type="datetime-local" id="dateTimeInputModal" />
<button onclick="saveDateTime()">Save</button>
<button onclick="closeDateTimeModal()">Cancel</button>
</div>


<script>
const dbName = 'ClockInOutDB';
const calstoreName = 'calStore';
	//calendar related items
const clockstoreName = 'clockStore';
	//Clock In and Out store
const settingsstoreName = 'settingsStore';
let callovertimerate,noncallovertimerate, callcodeswithstarttimes; 
let db;

function initDB(callback) {
	if (navigator.storage && navigator.storage.persist) {
		navigator.storage.persist().then(function(isPersistent) {
										 if (isPersistent) {
										 console.log("Storage is set to persistent.");
										 } else {
										 console.log("Storage is not persistent.");
										 }
										 }).catch(function(error) {
												  console.error("Error requesting persistent storage:", error);
												  });
	} else {
		console.log("Persistent storage is not supported by this browser.");
	}
	
	const request = indexedDB.open(dbName, 2);
	
	request.onupgradeneeded = function(event) {
		db = event.target.result;
		
		let clockStore;
		if (!db.objectStoreNames.contains(clockstoreName)) {
			clockStore = db.createObjectStore(clockstoreName, {
											  keyPath: 'id',
											  autoIncrement: true
											  });
		} else {
			clockStore = request.transaction.objectStore(clockstoreName);
		}
		
			// Add the index on date and assignment
		if (!clockStore.indexNames.contains('date_index')) {
			
			clockStore.createIndex('date_index', ['date'], {
								   unique: false
								   })
		}
		
		if (!db.objectStoreNames.contains(calstoreName)) {
			db.createObjectStore(calstoreName, {
								 keyPath: 'id',
								 autoIncrement: true
								 });
		}
		if (!db.objectStoreNames.contains(settingsstoreName)) {
			db.createObjectStore(settingsstoreName, {
								 keyPath: 'id',
								 autoIncrement: true
								 });
		}
		
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'database-ready'
																		   });
										   });
	}
	;
	
	request.onsuccess = function(event) {
		db = event.target.result;
		if (callback)
			callback();
		loadQGendaURL();
		loadCurrentSettings();
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'database-ready'
																		   });
										   });
	}
	;
	
	request.onerror = function(event) {
		console.error('IndexedDB error:', event.target.errorCode);
	}
	;
}


function getTransaction(storeName, mode) {
		//Check if dB is ready or initialized.
	if (db && db.objectStoreNames.contains([storeName])) {
		const transaction = db.transaction([storeName], mode);
		return transaction.objectStore(storeName);
	} else {
		console.log("getTransaction -db not ready or doesn't have requested store = " + storeName);
	}
}

async function loadCurrentSettings(){
const store = getTransaction(settingsstoreName, 'readonly');	
	
}
async function saveQGendaURL(url) {
	const store = getTransaction(calstoreName, 'readwrite');
	store.put({
			  id: 'qgendaurl',
			  value: url
			  });
}

async function loadQGendaURL() {
	const store = getTransaction(calstoreName, 'readonly');
	const request = store.get('qgendaurl');
	request.onsuccess = function(event) {
		const result = event.target.result;
		if (result) {
			document.getElementById('qgendaurl').value = result.value;
		}
	}
	;
}

async function saveRecord(record) {
	const store = getTransaction(clockstoreName, 'readwrite');
	store.put(record);
}

function handleURLupdate() {
	const newurl = convertUrlPrefix(document.getElementById('qgendaurl').value);
	document.getElementById('qgendaurl').value = newurl;
	saveQGendaURL(newurl);
	
	if ('serviceWorker'in navigator) {
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'fetch-calendar',
																		   data: {
																		   url: newurl
																		   }
																		   });
										   }).catch(error=>{
													console.error('Service Worker registration error:', error);
													}
													);
		
			// Listen for messages from the service worker
		navigator.serviceWorker.addEventListener('message', function(event) {
												 if (event.data.type === 'fetch-complete') {
												 if (event.data.status === 'success') {
												 console.log('Fetch complete, data is ready');
												 // Handle the successful fetch
												 displayTodaysAssignment();
												 } else if (event.data.status === 'error') {
												 console.error('Fetch failed:', event.data.error);
												 // Handle the error
												 }
												 }
												 });
	}
	
}
function setCurrentLocalDate() {
	const now = new Date();
	
		// Get the local year, month, and day, and format it to 'YYYY-MM-DD'
	const year = now.getFullYear();
	const month = String(now.getMonth() + 1).padStart(2, '0'); // Month is zero-indexed, so +1
	const day = String(now.getDate()).padStart(2, '0');
	
	const localDate = `${year}-${month}-${day}`;
	
		// Return the value of the date input field to the local date
	return localDate;
}


	// Function to format the date to "yyyy-MM-dd" without using .toISOString()
function formatDateToYYYYMMDD(date) {
	const year = date.getFullYear();
	const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based
	const day = String(date.getDate()).padStart(2, '0');
	return `${year}-${month}-${day}`;
}

function formatDateTime(inputDateTime) {
	const date = new Date(inputDateTime);
	const pad = (num, size) => num.toString().padStart(size, '0');
	const year = date.getFullYear();
	const month = pad(date.getMonth() + 1, 2);
	const day = pad(date.getDate(), 2);
	const hours = pad(date.getHours(), 2);
	const minutes = pad(date.getMinutes(), 2);
	const seconds = pad(date.getSeconds(), 2);
	return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
}

function formatDateTo7AM(dateString) {
		// Directly append the time to the provided date string, assuming it's in the format 'YYYY-MM-DD'
	return `${dateString}T07:00:00`;
}

function formatDateTo5PM(dateString) {
		// Directly append the time to the provided date string, assuming it's in the format 'YYYY-MM-DD'
	return `${dateString}T17:00:00`;
}

function initializeDateTimeInputs(callback) {
	const now = new Date();
	const localDateTime = formatDateTime(now);
	document.getElementById('dateTimeInput').value = setCurrentLocalDate();
	document.getElementById('startDate').value = setCurrentLocalDate();
	document.getElementById('endDate').value = setCurrentLocalDate();
	document.getElementById('ClockOutTimeInput').value = localDateTime;
	document.getElementById('ClockInTimeInput').value = localDateTime;
	
		// Check if assignment exists in the DB
	if (callback)
		callback();
}

async function getRecords() {
	const startDate = document.getElementById('startDate').value;
	const endDate = document.getElementById('endDate').value;
	
	const store = getTransaction(clockstoreName, 'readonly');
	const request = store.getAll();
	request.onsuccess = function(event) {
		const records = event.target.result;
		const filteredRecords = records.filter(record=>{
											   return new Date(record.date) >= new Date(startDate) && new Date(record.date) <= new Date(endDate);

											   }
											   );
		
		if (filteredRecords.length === 0) {
			alert('No data exists for the selected time period.');
			return;
		}
		
		const csvContent = generateCSV(filteredRecords);
		downloadCSV(csvContent, `records_ ${startDate}_ ${endDate}.csv`);
	}
	;
}

function generateCSV(records) {
	const csvHeaders = ['Date', 'Assignment', 'Clock-in Time', 'Clock-out Time', 'Hours Worked', 'Overtime','Session Pay'];
	const csvRows = [csvHeaders.join(',')];
	
	records.forEach(record=>{
					const row = [`"${record.date}"`,`"${record.assignment}"`, `"${record.clockInTime}"`, `"${record.clockOutTime}"`, `"${record.hoursWorked}"`,`"${record.overtime}"`,`"${record.sessionPay}"`];
					csvRows.push(row.join(','));
					}
					);
	
	return csvRows.join('\n');
}

function downloadCSV(csvContent, filename) {
	const blob = new Blob([csvContent],{
						  type: 'text/csv'
						  });
	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	a.download = filename;
	a.click();
	URL.revokeObjectURL(url);
}




  
										  
										  
										  function getLastWeekRecords() {
										  const endDate = new Date();
										  const startDate = new Date();
										  startDate.setDate(endDate.getDate() - 7);
											  document.getElementById('startDate').value = formatDateToYYYYMMDD(startDate);
											  document.getElementById('endDate').value = formatDateToYYYYMMDD(endDate);
										  getRecords();
										  }
										  
										  function getLastMonthRecords() {
										  const endDate = new Date();
										  const startDate = new Date();
										  startDate.setMonth(endDate.getMonth() - 1);
											  document.getElementById('startDate').value = formatDateToYYYYMMDD(startDate);
											  document.getElementById('endDate').value = formatDateToYYYYMMDD(endDate);
										  getRecords();
										  }
										  
										  function clearIndexedDB() {
										  const request = indexedDB.deleteDatabase(dbName);
										  request.onsuccess = function() {
										  alert('IndexedDB cleared.');
										  initDB();
										  }
										  ;
										  request.onerror = function(event) {
										  console.error('IndexedDB clear error:', event.target.errorCode);
										  }
										  ;
										  }
										  
										  function getAssignmentsByDate(date) {
										  const store = getTransaction(clockstoreName, 'readonly');
										  const index = store.index('date_index');
										  // Assumes you have an index on date and assignment
										  
										  const query = IDBKeyRange.only([date]);
										  const request = index.getAll(query);
										  
										  return new Promise((resolve,reject)=>{
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 }
															 ;
															 request.onerror = function(event) {
															 reject('Failed to retrieve assignment');
															 }
															 ;
															 }
															 );
										  }
										  
										  // Example usage:
										  /*
										   getAssignmentByDateAndSummary('2024-08-29', 'Morning Shift').then((result) => {
										   if (result) {
										   console.log('Assignment found:', result);
										   } else {
										   console.log('Assignment not found');
										   }
										   }).catch((error) => {
										   console.error(error);
										   });
										   
										   
										   */
										  
										  let currentPrimaryKey;
										  let currentWhichTime;
										  
										  
										  function saveDateTime() {
										  const dateTimeInput = document.getElementById('dateTimeInputModal').value;
										  if (dateTimeInput) {
										  updateRecord(currentPrimaryKey, currentWhichTime, dateTimeInput);
										  }
										  closeDateTimeModal();
										  }
										  
										  function closeDateTimeModal() {
										  document.getElementById('dateTimeModal').style.display = 'none';
										  }
										  
										  async function editTimes(primaryKey, whichTime) {
										  currentPrimaryKey = primaryKey;
										  currentWhichTime = whichTime;
										  
										  // Display the modal
										  const modal = document.getElementById('dateTimeModal');
										  modal.style.display = 'block';
										  
										  const record = await getRecordById(primaryKey);
										  const localDateTime = formatDateTime(new Date());
										  
										  // Set the default value of the date-time picker
										  const dateTimeInput = document.getElementById('dateTimeInputModal');
										  dateTimeInput.value = whichTime === 'clockIn' ? record.clockInTime || localDateTime : record.clockOutTime || localDateTime;
										  }

async function editTimesfromInput(primaryKey, whichTime) {
	currentPrimaryKey = primaryKey;
	currentWhichTime = whichTime;

	const record = await getRecordById(primaryKey);
	const localDateTime = formatDateTime(new Date());
	const dateTimeInput = document.getElementById(whichTime+'input'+primaryKey);
	if (dateTimeInput) {
		
		updateRecord(currentPrimaryKey, currentWhichTime, dateTimeInput.value);
	}
}
										  async function updateRecord(primaryKey, whichTime, selectedDateTime) {
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const updateRequest = store.get(primaryKey);
										  
										  updateRequest.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record based on whichTime
										  if (whichTime === 'clockIn') {
										  record.clockInTime = selectedDateTime;
										  } else if (whichTime === 'clockOut') {
										  record.clockOutTime = selectedDateTime;
										  }
										//Calculate overtime, hours worked etc based on new times.
											  record.assignment = document.getElementById('storedassignmentInput' + primaryKey).value;
											  
												  // Calculate hours worked
											  record.hoursWorked = calculateHoursWorked(record.clockInTime, record.clockOutTime);
											  
												  // Calculate overtime
											  record.overtime = calculateOvertime(record.clockOutTime, record.assignment, record.date, record.clockInTime);
											  
												  // Calculate session pay
											  record.sessionPay = calculateSessionPay(record.overtime, record.assignment);  
										  
										  // Save the updated record back into the object store
										  const putRequest = store.put(record);
										  putRequest.onsuccess = function() {
										  // Update the displayed value in the corresponding cell
											  displayTodaysAssignment();
										  };
										  putRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.error);
										  };
										  }
										  };
										  updateRequest.onerror = function(event) {
										  console.error('Error retrieving record:', event.target.error);
										  };
										  }
										  
										  // Helper function to retrieve a record by its primary key
										  async function getRecordById(primaryKey) {
										  return new Promise((resolve, reject) => {
															 const store = getTransaction(clockstoreName, 'readonly');
															 const request = store.get(primaryKey);
															 
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 };
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 };
															 });
										  }


										  async function clockIn(primaryKey) {
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const request = store.get(primaryKey);
										  
										  request.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record with clockInTime
										  record.clockInTime = localDateTime; // Current time
											// redundant to update the assignemnt here as well but just in case the user happens to click the clockin or clockout faster than the debounce time of 500 ms - it will capture the updated assignment here.
										record.assignment = document.getElementById('storedassignmentInput'+primaryKey).value;
										  // Save the updated record back into the object store
										  const updateRequest = store.put(record);
										  
										  updateRequest.onsuccess = function(event) {
										  // Update the UI after successful clock in
										  
										  
										  // Add the Edit button next to the clockIn time
										  
										  };
										  
										  updateRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.errorCode);
										  };
										  } else {
										  console.log('Record not found');
										  // Handle case where the record does not exist
										  const assignment = document.getElementById('storedassignmentInput'+primaryKey).value;
										  const formattedToday = document.getElementById('dateTimeInput').value;
										  const clockInTime = document.getElementById('ClockInTimeInput').value;
										  if (formattedToday) {
										  const newStore = getTransaction(clockstoreName, 'readwrite');
										  newStore.put({
													   date: formattedToday,
													   clockInTime: clockInTime, // Use localDateTime here for consistency
													   assignment: assignment,
													   clockOutTime: null, // Leave clockOutTime as null
													   });
										  
										  
										  } else {
										  alert('Please enter your assignment and select a date/time.');
										  }
										  }
										  };
										  
										  request.onerror = function(event) {
										  console.log('Failed to retrieve record:', event.target.errorCode);
										  };
										  displayTodaysAssignment();
										  }


										  
	// Global variables for session pay rates
const callRate = 200; // Example rate, update accordingly
const nonCallRate = 250; // Example rate, update accordingly

async function clockOut(primaryKey) {
	const store = getTransaction(clockstoreName, 'readwrite');
	if (!store) {
		alert('Database store is not available. Please try again later.');
		return;
	}
	
	const request = store.get(primaryKey);
	
	request.onsuccess = function(event) {
		const record = event.target.result;
		if (record) {
			const clockOutTimeInput = document.getElementById('ClockOutTimeInput' + primaryKey);
			if (!clockOutTimeInput || !clockOutTimeInput.value) {
				alert("Please provide a valid clock-out time.");
				return;
			}
			
			const clockOutTime = clockOutTimeInput.value;
			const clockInTime = record.clockInTime ? new Date(record.clockInTime) : formatDateTo7AM(record.date);
			
				// Validation: clockOutTime must be at least 30 minutes after clockInTime
			const clockOut = new Date(clockOutTime);
			if ((clockOut - clockInTime) < (30 * 60 * 1000)) {
				alert("Clock out time must be at least 30 minutes after clock in time.");
				return;
			}
			
				// Update the record with clockOutTime
			record.clockOutTime = clockOutTime;
			record.assignment = document.getElementById('storedassignmentInput' + primaryKey).value;
			
				// Calculate hours worked
			record.hoursWorked = calculateHoursWorked(clockInTime, clockOutTime);
			
				// Calculate overtime
			record.overtime = calculateOvertime(clockOutTime, record.assignment, record.date, clockInTime);
			
				// Calculate session pay
			record.sessionPay = calculateSessionPay(record.overtime, record.assignment);
			
				// Save the updated record back into the object store
			const updateRequest = store.put(record);
			
			updateRequest.onsuccess = function(event) {
					// Update the UI after successful clock out
			
				
					// Add the Edit button next to the clockOut time
			
			};
			
			updateRequest.onerror = function(event) {
				console.error('Error updating record:', event.target.errorCode);
			};
		} else {
			console.log('Record not found');
			const assignmentInput = document.getElementById('storedassignmentInput'+primaryKey);
			const dateTimeInput = document.getElementById('dateTimeInput');
			
			if (!assignmentInput || !dateTimeInput) {
				alert('Please enter your assignment and select a date/time.');
				return;
			}
			
			const assignment = assignmentInput.value;
			const formattedToday = dateTimeInput.value;
			
			if (formattedToday) {
				const newStore = getTransaction(clockstoreName, 'readwrite');
				if (!newStore) {
					alert('Database store is not available. Please try again later.');
					return;
				}
				
				const clockOutTime = document.getElementById('ClockOutTimeInput').value;
				const clockInTime = formatDateTo7AM(formattedToday);
				const clockOut = new Date(clockOutTime);
				if ((clockOut - clockInTime) < (30 * 60 * 1000)) {
					alert("Clock out time must be at least 30 minutes after clock in time.");
					return;
				}
				
				const overtime = calculateOvertime(clockOutTime, assignment, formattedToday, clockInTime);
				
				newStore.put({
							 date: formattedToday,
							 clockInTime: clockInTime, // Default clock in time 7 AM
							 assignment: assignment,
							 clockOutTime: clockOutTime,
							 hoursWorked: calculateHoursWorked(clockInTime, clockOutTime),
							 overtime: overtime,
							 sessionPay: calculateSessionPay(overtime, assignment),
							 });
				
				
			} else {
				alert('Please enter your assignment and select a date/time.');
			}
		}
	};
	
	request.onerror = function(event) {
		console.log('Failed to retrieve record:', event.target.errorCode);
	};
	displayTodaysAssignment();
}


	// Function to calculate hours worked in 15-minute increments
function calculateHoursWorked(clockInTime, clockOutTime) {
	const diff = new Date(clockOutTime) - new Date(clockInTime); // Difference in milliseconds
	const diffInMinutes = Math.round(diff / (1000 * 60)); // Difference in minutes
	const roundedMinutes = Math.ceil(diffInMinutes / 15) * 15; // Round up to nearest 15 minutes
	const hoursWorked = roundedMinutes / 60; // Convert to hours
	return hoursWorked;
}

function calculateOvertime(clockOutTime, assignment, date, clockInTime) {
	const clockOut = new Date(clockOutTime);
	const clockIn = new Date(clockInTime);
		// Extract day of the week
	const dayOfWeek = new Date(`${date}T00:00:00`).getDay(); // Avoids GMT/UTC issue by using midnight time
	
	let overtime = 0;
	
		// Debugging output
	console.log(`Day of week: ${dayOfWeek}`);
	console.log(`Assignment: ${assignment}`);
	
		// If the day is Saturday (6) or Sunday (0), calculate total time as overtime
	if (dayOfWeek === 0 || dayOfWeek === 6) {
		overtime = (clockOut - clockIn) / (1000 * 60 * 60); // Calculate total hours
		overtime+=1; // Add an hour of activation over the weekends.
		console.log(`Weekend Overtime: ${overtime}`);
	} else {
			// Convert endOfDay string to local time zone
		const endOfDayString = `${date}T17:00:00`; // 5 PM of the same day
		const endOfDay = new Date(endOfDayString.replace("T", " ")); // Local time interpretation
		
		console.log(`End of Day: ${endOfDay}`); // Debugging output
		
		if (assignment.includes("CC")) {
			console.log(`CC Assignment detected`);
			
				// Calculate next day at 1 AM without using new Date()
			const nextDay1AM = new Date(increaseDateByOneDay(date) + 'T01:00:00'.replace("T", " ")); // Local time
			console.log(`Next Day 1 AM: ${nextDay1AM}`);
			
				// Overtime if clockOut is after 1 AM the next day
			if (clockOut > nextDay1AM) {
				overtime = (clockOut - nextDay1AM) / (1000 * 60 * 60); // Hours in overtime
				console.log(`Overtime after 1 AM: ${overtime}`);
			}
			
				// Overtime if clockIn is before 2 PM
			const cutoffTime2PM = new Date(`${date}T14:00:00`.replace("T", " ")); // Local time
			if (clockIn < cutoffTime2PM) {
				overtime += (cutoffTime2PM - clockIn) / (1000 * 60 * 60); // Add early overtime hours
				console.log(`Overtime before 2 PM: ${overtime}`);
			}
		} else {
				// Standard overtime calculation for non-CC assignments
			console.log(`Non-CC Assignment detected`);
			if (clockOut > endOfDay) {
				overtime = (clockOut - endOfDay) / (1000 * 60 * 60); // Hours in overtime
				console.log(`Overtime after 5 PM: ${overtime}`);
			}
		}
	}
	
		// Round overtime to the nearest 15 minutes
	const roundedOvertime = Math.ceil(overtime * 4) / 4;
	console.log(`Final Rounded Overtime: ${roundedOvertime}`); // Debugging output
	
	return roundedOvertime;
}



	// Helper function to increase date by one day
function increaseDateByOneDay(dateString) {
	const dateParts = dateString.split('-');
	const year = parseInt(dateParts[0], 10);
	const month = parseInt(dateParts[1], 10) - 1; // Month is zero-based in JavaScript
	const day = parseInt(dateParts[2], 10);
	
	const date = new Date(year, month, day);
	date.setDate(date.getDate() + 1);
	
		// Format back to 'YYYY-MM-DD'
	const newYear = date.getFullYear();
	const newMonth = (date.getMonth() + 1).toString().padStart(2, '0');
	const newDay = date.getDate().toString().padStart(2, '0');
	
	return `${newYear}-${newMonth}-${newDay}`;
}



	// Function to calculate session pay based on overtime and assignment
function calculateSessionPay(overtime, assignment) {
	const rate = (assignment.includes("C1M") || assignment.includes("CC")) ? callRate : nonCallRate;
	return overtime * rate;
}


// Create a debounced version of handleUpdatedAssignment
const debouncedHandleUpdatedAssignment = debounce(handleUpdatedAssignment, 500);


async function handleUpdatedAssignment(primaryKey){
	const store = getTransaction(clockstoreName, 'readwrite');
	const request = store.get(primaryKey);
	
	request.onsuccess = function(event) {
		const record = event.target.result;
		if (record) {
				// Update the record with clockOutTime
			record.assignment = document.getElementById('storedassignmentInput'+primaryKey).value;
			
				// Save the updated record back into the object store
			const updateRequest = store.put(record);
			
			updateRequest.onsuccess = function(event) {
				console.log("Assignment updated");
			};
			updateRequest.onerror = function(event) {
				console.error('Error updating record:', event.target.errorCode);
			};
		}else {
			console.log('Record not found');
		}
	};
		request.onerror = function(event) {
			console.log('Failed to retrieve record:', event.target.errorCode);
		};
	
}
										  
										  async function displayTodaysAssignment() {
										  // Clear and reset the clock in/clock out times and buttons
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  const formattedToday = document.getElementById('dateTimeInput').value;
										  // Reset clockIn, clockOut times and buttons
										  document.getElementById('ClockOutTimeInput').value = localDateTime;
										  document.getElementById('ClockInTimeInput').value = formatDateTo7AM(formattedToday); // set it to the day of assignments 7 am
										  document.getElementById('storedassignmentInput0').value = null;
										  //document.getElementById('clockInOut').style.display = "block"; // Ensure clockInOut is visible

										  
										  
										  try {
										  // Check if today's assignment is already in the IndexedDB
										  const todayAssignment = await getAssignmentFromDB(formattedToday);
										  
										  if (todayAssignment) {
										  // Assignment for today exists in IndexedDB
										  document.getElementById('assignmentInput').value = todayAssignment.assignment; 
										  document.getElementById('storedassignmentInput0').value = todayAssignment.assignment;
										  }
										  
										  // Get assignments for today and update the table
										  const result = await getAssignmentsByDate(formattedToday);
										  const mytable = document.getElementById("mytable");
												  // Clear the table if needed
											  mytable.innerHTML = "";
											  
											  if (result && result.length > 0) {
													  // Create the table structure with row headers for each field (ID, Date, Assignment, etc.)
												  const headerRow = document.createElement("tr");
												  const dateRow = document.createElement("tr");
												  const assignmentRow = document.createElement("tr");
												  const clockInRow = document.createElement("tr");
												  const clockOutRow = document.createElement("tr");
												  const hoursWorkedRow = document.createElement("tr");
												  const overtimeRow = document.createElement("tr");
												  const sessionPayRow = document.createElement("tr");
												  const deleteRow = document.createElement("tr");
												  
													  // Add row headers
												  headerRow.appendChild(document.createElement("th")); // Empty corner cell
												  dateRow.appendChild(document.createElement("th")).textContent = "Date";
												  assignmentRow.appendChild(document.createElement("th")).textContent = "Assignment";
												  clockInRow.appendChild(document.createElement("th")).textContent = "Clock In";
												  clockOutRow.appendChild(document.createElement("th")).textContent = "Clock Out";
												  hoursWorkedRow.appendChild(document.createElement("th")).textContent = "Hours Worked";
												  overtimeRow.appendChild(document.createElement("th")).textContent = "Over Time";
												  sessionPayRow.appendChild(document.createElement("th")).textContent = "Session Pay";
												  deleteRow.appendChild(document.createElement("th")).textContent = "Delete";
												  
													  // Append each individual result as columns in the respective rows
												  result.forEach(function(individualresult) {
																 // Date Cell
																 const dateCell = document.createElement("td");
																 dateCell.textContent = individualresult.date;
																 dateCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 dateRow.appendChild(dateCell);
																 
																 // Assignment Cell
																 const assignmentCell = document.createElement("td");
																 const assignmentInputfromTable = document.createElement("input");
																 assignmentInputfromTable.type = "text";
																 assignmentInputfromTable.id = "storedassignmentInput" + individualresult.id;
																 assignmentInputfromTable.value = individualresult.assignment;
																 assignmentInputfromTable.oninput = () => debouncedHandleUpdatedAssignment(individualresult.id);
																 assignmentCell.appendChild(assignmentInputfromTable);
																 assignmentCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 assignmentRow.appendChild(assignmentCell);
																 
																 // Clock In Cell
																 const clockInCell = document.createElement("td");
																 if (individualresult.clockInTime) {
																 const myclockInInput = document.createElement("input");
																 myclockInInput.type = "datetime-local";
																 myclockInInput.id = "clockIn" + "input" + individualresult.id;
																 myclockInInput.value = individualresult.clockInTime;
																 myclockInInput.onchange = () => editTimesfromInput(individualresult.id, "clockIn");
																 clockInCell.appendChild(myclockInInput);
																 } else {
																 const clockInButton = document.createElement("button");
																 clockInButton.textContent = "Clock In";
																 clockInButton.onclick = () => clockIn(individualresult.id);
																 clockInCell.appendChild(clockInButton);
																 }
																 clockInCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 clockInRow.appendChild(clockInCell);
																 
																 // Clock Out Cell
																 const clockOutCell = document.createElement("td");
																 if (individualresult.clockOutTime) {
																 const myclockOutInput = document.createElement("input");
																 myclockOutInput.type = "datetime-local";
																 myclockOutInput.id = "clockOut" + "input" + individualresult.id;
																 myclockOutInput.value = individualresult.clockOutTime;
																 myclockOutInput.onchange = () => editTimesfromInput(individualresult.id, "clockOut");
																 clockOutCell.appendChild(myclockOutInput);
																 } else {
																 const ClockOutTimeInputfromTable = document.createElement("input");
																 ClockOutTimeInputfromTable.type = "datetime-local";
																 ClockOutTimeInputfromTable.id = "ClockOutTimeInput" + individualresult.id;
																 ClockOutTimeInputfromTable.value = localDateTime;
																 const clockOutButton = document.createElement("button");
																 clockOutButton.textContent = "Clock Out";
																 clockOutButton.onclick = () => clockOut(individualresult.id);
																 clockOutCell.appendChild(ClockOutTimeInputfromTable);
																 clockOutCell.appendChild(clockOutButton);
																 }
																 clockOutCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 clockOutRow.appendChild(clockOutCell);
																 
																 // Hours Worked Cell
																 const hoursWorkedCell = document.createElement("td");
																 if (individualresult.hoursWorked) {
																 hoursWorkedCell.textContent=individualresult.hoursWorked;
																 } 
																 hoursWorkedCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 hoursWorkedRow.appendChild(hoursWorkedCell);
																 
																 // Over Time cell
																 const overtimeCell = document.createElement("td");
																 if (individualresult.overtime) {
																 overtimeCell.textContent=individualresult.overtime;
																 } 
																 overtimeCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 overtimeRow.appendChild(overtimeCell);
																 
																 
																 // Session Pay Cell
																 const sessionPayCell = document.createElement("td");
																 if (individualresult.sessionPay) {
																 sessionPayCell.textContent=individualresult.sessionPay;
																 } 
																 sessionPayCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 sessionPayRow.appendChild(sessionPayCell);
																 
																 
																 // Delete Button Cell
																 const deleteCell = document.createElement("td");
																 const deleteButton = document.createElement("button");
																 const svgDeleteIcon = createDeleteIcon(); // Custom function for SVG creation
																 deleteButton.appendChild(svgDeleteIcon);
																 deleteButton.onclick = () => deleteRecord(individualresult.id);
																 deleteCell.appendChild(deleteButton);
																 deleteCell.setAttribute("data-column-id", `column${individualresult.id}`); // Assign data-column-id
																 deleteRow.appendChild(deleteCell);
																 });
												  
													  // Append all rows to the table
												  mytable.appendChild(headerRow);
												  mytable.appendChild(dateRow);
												  mytable.appendChild(assignmentRow);
												  mytable.appendChild(clockInRow);
												  mytable.appendChild(clockOutRow);
												  mytable.appendChild(hoursWorkedRow);
												  mytable.appendChild(overtimeRow);
												  mytable.appendChild(sessionPayRow);
												  mytable.appendChild(deleteRow);
											  }
 else {
										  // If no results, ensure clockInOut is visible
										  //document.getElementById('clockInOut').style.display = "block";
										  console.log("No assignments found for today.");
										  }
										  } catch (error) {
										  console.error('Error displaying today\'s assignment:', error);
										  }
										  }


async function deleteRecord(primaryKey) {
	const store = getTransaction(clockstoreName, 'readwrite'); // Open a readwrite transaction
	const request = store.delete(primaryKey); // Delete the record with the given primary key
	
	request.onsuccess = function(event) {
		console.log(`Record with primaryKey ${primaryKey} deleted successfully!`);
		
			// Remove the corresponding column from the UI
		const columnToDelete = document.querySelectorAll(`[data-column-id="column${primaryKey}"]`);
		
		columnToDelete.forEach(cell => {
							   cell.remove(); // Remove each cell corresponding to the column for the deleted record
							   });
	};
	
	request.onerror = function(event) {
		console.error('Error deleting record:', event.target.error); // Use event.target.error for more detailed error information
	};
}


	// Function to create the Edit SVG Icon
function createEditIcon() {
	const svgEditIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
	svgEditIcon.setAttribute("viewBox", "0 0 24 24");
	svgEditIcon.setAttribute("fill", "none");
	svgEditIcon.setAttribute("stroke", "currentColor");
	svgEditIcon.setAttribute("stroke-width", "2");
	svgEditIcon.setAttribute("stroke-linecap", "round");
	svgEditIcon.setAttribute("stroke-linejoin", "round");
	svgEditIcon.style.width = "24px";
	svgEditIcon.style.height = "24px";
	
	const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path1.setAttribute("d", "M11 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7");
	const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path2.setAttribute("d", "M18.5 2.5a2.121 2.121 0 1 1 3 3L13 14l-4 1 1-4 8.5-8.5z");
	
	svgEditIcon.appendChild(path1);
	svgEditIcon.appendChild(path2);
	
	return svgEditIcon;
}

	// Function to create the Delete SVG Icon
function createDeleteIcon() {
	const svgDeleteIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
	svgDeleteIcon.setAttribute("viewBox", "0 0 24 24");
	svgDeleteIcon.setAttribute("fill", "none");
	svgDeleteIcon.setAttribute("stroke", "currentColor");
	svgDeleteIcon.setAttribute("stroke-width", "2");
	svgDeleteIcon.setAttribute("stroke-linecap", "round");
	svgDeleteIcon.setAttribute("stroke-linejoin", "round");
	svgDeleteIcon.style.width = "24px";
	svgDeleteIcon.style.height = "24px";
	
	const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path1.setAttribute("d", "M3 6h18");
	const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path2.setAttribute("d", "M19 6l-2 14H7L5 6");
	const path3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path3.setAttribute("d", "M10 11v6");
	const path4 = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path4.setAttribute("d", "M14 11v6");
	
	svgDeleteIcon.appendChild(path1);
	svgDeleteIcon.appendChild(path2);
	svgDeleteIcon.appendChild(path3);
	svgDeleteIcon.appendChild(path4);
	
	return svgDeleteIcon;
}
										  
										  
										  function getRecordsByDate(date, callback) {
										  const store = getTransaction(clockstoreName, 'readonly');
										  const index = store.index('date_index');
										 
										  // Query by date
										  
										  const keyRange = IDBKeyRange.only([date]);
										  
										  //const request = index.openKeyCursor(keyRange);
										  const request = index.getAll(keyRange);
										  request.onsuccess = function(event) {
										  const records = event.target.result; console.log(records);
										  if (records) { callback(records);} else {console.log ("No records");}
										  // Handle the array of records
										  }
										  ;
										  
										  request.onerror = function(event) {
										  console.error('Error fetching records by date:', event.target.errorCode);
										  }
										  ;
										  }

										  
										  // Function to get an assignment from IndexedDB
										  function getAssignmentFromDB(date) {
										  return new Promise((resolve,reject)=>{
															 const store = getTransaction(calstoreName, 'readonly');
															 const request = store.get(date);
															 
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 }
															 ;
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 }
															 ;
															 }
															 );
										  }
										  
										  // Function to update assignment in IndexedDB
										  function updateAssignmentInDB(date, summary) {
										  return new Promise((resolve,reject)=>{
															 const store = getTransaction(calstoreName, 'readwrite');
															 const request = store.get(date);
															 
															 request.onsuccess = function(event) {
															 const result = event.target.result;
															 if (result) {
															 // Replace the existing assignment with the new summary
															 store.put({
																	   id: date,
																	   date: date,
																	   assignment: summary
																	   });
															 } else {
															 // Store new assignment
															 store.put({
																	   id: date,
																	   date: date,
																	   assignment: summary
																	   });
															 }
															 resolve();
															 }
															 ;
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 }
															 ;
															 }
															 );
										  }
										  
										  // Utility functions (unchanged)
										  function parseCustomDate(dateString) {
										  const year = dateString.slice(0, 4);
										  const month = dateString.slice(4, 6) - 1;
										  // Months are 0-indexed in JavaScript
										  const day = dateString.slice(6, 8);
										  
										  return new Date(year,month,day);
										  }
										  
										  function formatQDate(date) {
										  return date.split('T')[0];
										  }
										  
										  function parseICalendar(data) {
										  const events = [];
										  const lines = data.split('\n');
										  let event = null;
										  
										  for (const line of lines) {
										  if (line.startsWith('BEGIN:VEVENT')) {
										  event = {
										  details: {}
										  };
										  } else if (line.startsWith('SUMMARY:')) {
										  event.details.summary = line.replace('SUMMARY:', '');
										  } else if (line.startsWith('DTSTART;VALUE=DATE:')) {
										  event.details.start = line.replace('DTSTART;VALUE=DATE:', '');
										  } else if (line.startsWith('DTEND;VALUE=DATE:')) {
										  event.details.end = line.replace('DTEND;VALUE=DATE:', '');
										  } else if (line.startsWith('END:VEVENT')) {
										  if (event) {
										  events.push(event);
										  event = null;
										  }
										  }
										  }
										  return events;
										  }
										  
										  function convertUrlPrefix(url) {
										  const oldPrefix = "https://app.qgenda.com/ical";
										  const newPrefix = "/clock/qgenda/ical";
										  
										  // Replace the old prefix with the new prefix
										  if (url.startsWith(oldPrefix)) {
										  return url.replace(oldPrefix, newPrefix);
										  } else {
										  return url;
										  // Return the original URL if it doesn't match the old prefix
										  }
										  }
										  
										  function checkAndDisplayAssignment() {
										  if (db && db.objectStoreNames.contains(calstoreName)) {
										  displayTodaysAssignment();
										  } else {
										  console.error('Database not initialized or calstoreName does not exist.');
										  }
										  }
										  
										  // Ensure proper sequencing
										  window.onload = function() {
										  initDB(function() {
												 initializeDateTimeInputs(function() {
																		  checkAndDisplayAssignment();
																		  });
												 });
										  }
										  ;
										  
										  document.getElementById('qgendaurl').addEventListener('blur', function() {
																								const url = this.value;
																								if (url) {
																								handleURLupdate(url);
																								}
																								});
										  
										  function debounce(func, delay) {
										  let timeout;
										  return function(...args) {
										  clearTimeout(timeout);
										  timeout = setTimeout(()=>func.apply(this, args), delay);
										  }
										  ;
										  }
										  
										  document.getElementById('assignmentInput').addEventListener('input', debounce(function() {
																														const url = this.value;
																														if (url) {
																														handleUpdatedAssignment(url);
																														}
																														}, 500));
										  // Adjust the delay as needed
										  
										  document.getElementById('dateTimeInput').addEventListener('change', function() {
																									const url = this.value;
																									if (url) {
																									displayTodaysAssignment();
																									}
																									});
										  
										  window.addEventListener('focus', function() {
																  //console.log('Window is back in focus');
																  initializeDateTimeInputs(function() {
																						   checkAndDisplayAssignment();
																						   });
																  
																  });
										  
										  function handleDateUpdate(event) {
										  const selectedDate = event.target.value;
										  if (selectedDate) {
										  // Your logic here
										  console.log('User selected date:', selectedDate);
										  }
										  }
if ('serviceWorker' in navigator) {
	navigator.serviceWorker.register('./service-worker.js').then((registration) => {
																console.log('Service Worker registered with scope: ', registration.scope);
																
																// Check if a new service worker is waiting to activate
																if (registration.waiting) {
																promptUserForHardReload(registration.waiting);
																}
																
																// Listen for updates in the service worker
																registration.addEventListener('updatefound', () => {
																							  const newWorker = registration.installing;
																							  
																							  // If a new worker is found and it becomes waiting
																							  newWorker.addEventListener('statechange', () => {
																														 if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
																														 // A new service worker is installed but waiting for activation
																														 promptUserForHardReload(newWorker);
																														 }
																														 });
																							  });
																}).catch((error) => {
																		 console.log('Service Worker registration failed: ', error);
																		 });
}

	// Prompt the user for a hard reload
function promptUserForHardReload(worker) {
	const reloadButton = document.createElement('button');
	reloadButton.textContent = 'New version available. Click to update!';
	document.body.appendChild(reloadButton);
	
	reloadButton.addEventListener('click', () => {
								  // Tell the new service worker to skip waiting
								  worker.postMessage({ action: 'skipWaiting' });
								  
								  // Once the new service worker is activated, reload the page to fetch new assets
								  worker.addEventListener('statechange', () => {
														  if (worker.state === 'activated') {
														  window.location.reload(true); // This forces a hard-reload and bypasses the cache
														  }
														  });
								  });
}


										  </script>
										  </body>
										  </html>
										  
