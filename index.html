<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clock In/Out Tracker</title>
<link rel="manifest" href="./manifest.json">
<link rel="icon" href="./icons/favicon.ico" type="image/x-icon">
<style>
body {
	font-family: Arial, sans-serif;
margin: 50px;
}

.container {
	max-width: 300px;
margin: auto;
	text-align: center;
}

input[type="text"], input[type="datetime-local"], button {
padding: 10px;
margin: 5px;
width: 100%;
}
</style>
</head>
<body>
<div class="container">
<h1>Clock In/Out</h1>
<input type="text" id="qgendaurl" placeholder="Enter Qgenda Calendar URL">
<input type="date" id="dateTimeInput">
<input type="hidden" id="assignmentInput" placeholder="Enter your assignment">
<input type="text" id="storedassignmentInput" placeholder="Enter your assignment">
<table id="mytable"></table>
<div id='clockInOut'>
<input type="datetime-local" id="ClockInTimeInput">
<button id="clockInButton" onclick="clockIn('0')">Clock In</button>
<input type="datetime-local" id="ClockOutTimeInput">
<button id="clockOutButton" onclick="clockOut('0')">Clock Out</button>
</div>
<h2>Get Records</h2>
<input type="date" id="startDate">
<input type="date" id="endDate">
<button onclick="getRecords()">Get Records</button>
<button onclick="getLastWeekRecords()">Last Week</button>
<button onclick="getLastMonthRecords()">Last Month</button>
<!-- <button onclick="clearIndexedDB()">Clear IndexedDB</button> -->
</div>


<!-- HTML for the modal -->
<div id="dateTimeModal" style="display:none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid #ccc; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); z-index: 1000;">
<label for="dateTimeInputModal">Enter date and time:</label>
<input type="datetime-local" id="dateTimeInputModal" />
<button onclick="saveDateTime()">Save</button>
<button onclick="closeDateTimeModal()">Cancel</button>
</div>
<script>
const dbName = 'ClockInOutDB';
const calstoreName = 'calStore';
	//calendar related items
const clockstoreName = 'clockStore';
	//Clock In and Out store
let db;

function initDB(callback) {
	if (navigator.storage && navigator.storage.persist) {
		navigator.storage.persist().then(function(isPersistent) {
										 if (isPersistent) {
										 console.log("Storage is set to persistent.");
										 } else {
										 console.log("Storage is not persistent.");
										 }
										 }).catch(function(error) {
												  console.error("Error requesting persistent storage:", error);
												  });
	} else {
		console.log("Persistent storage is not supported by this browser.");
	}
	
	const request = indexedDB.open(dbName, 2);
	
	request.onupgradeneeded = function(event) {
		db = event.target.result;
		
		let clockStore;
		if (!db.objectStoreNames.contains(clockstoreName)) {
			clockStore = db.createObjectStore(clockstoreName, {
											  keyPath: 'id',
											  autoIncrement: true
											  });
		} else {
			clockStore = request.transaction.objectStore(clockstoreName);
		}
		
			// Add the index on date and assignment
		if (!clockStore.indexNames.contains('date_index')) {
			
			clockStore.createIndex('date_index', ['date'], {
								   unique: false
								   })
		}
		
		if (!db.objectStoreNames.contains(calstoreName)) {
			db.createObjectStore(calstoreName, {
								 keyPath: 'id',
								 autoIncrement: true
								 });
		}
		
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'database-ready'
																		   });
										   });
	}
	;
	
	request.onsuccess = function(event) {
		db = event.target.result;
		if (callback)
			callback();
		loadQGendaURL();
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'database-ready'
																		   });
										   });
	}
	;
	
	request.onerror = function(event) {
		console.error('IndexedDB error:', event.target.errorCode);
	}
	;
}

function getTransaction(storeName, mode) {
		//Check if dB is ready or initialized.
	if (db && db.objectStoreNames.contains([storeName])) {
		const transaction = db.transaction([storeName], mode);
		return transaction.objectStore(storeName);
	} else {
		console.log("getTransaction -db not ready or doesn't have requested store = " + storeName);
	}
}

async function saveQGendaURL(url) {
	const store = getTransaction(calstoreName, 'readwrite');
	store.put({
			  id: 'qgendaurl',
			  value: url
			  });
}

async function loadQGendaURL() {
	const store = getTransaction(calstoreName, 'readonly');
	const request = store.get('qgendaurl');
	request.onsuccess = function(event) {
		const result = event.target.result;
		if (result) {
			document.getElementById('qgendaurl').value = result.value;
		}
	}
	;
}

async function saveRecord(record) {
	const store = getTransaction(clockstoreName, 'readwrite');
	store.put(record);
}

function handleURLupdate() {
	const newurl = convertUrlPrefix(document.getElementById('qgendaurl').value);
	document.getElementById('qgendaurl').value = newurl;
	saveQGendaURL(newurl);
	
	if ('serviceWorker'in navigator) {
		navigator.serviceWorker.ready.then(function(registration) {
										   registration.active.postMessage({
																		   type: 'fetch-calendar',
																		   data: {
																		   url: newurl
																		   }
																		   });
										   }).catch(error=>{
													console.error('Service Worker registration error:', error);
													}
													);
		
			// Listen for messages from the service worker
		navigator.serviceWorker.addEventListener('message', function(event) {
												 if (event.data.type === 'fetch-complete') {
												 if (event.data.status === 'success') {
												 console.log('Fetch complete, data is ready');
												 // Handle the successful fetch
												 displayTodaysAssignment();
												 } else if (event.data.status === 'error') {
												 console.error('Fetch failed:', event.data.error);
												 // Handle the error
												 }
												 }
												 });
	}
	
}
function setCurrentLocalDate() {
	const now = new Date();
	
		// Get the local year, month, and day, and format it to 'YYYY-MM-DD'
	const year = now.getFullYear();
	const month = String(now.getMonth() + 1).padStart(2, '0'); // Month is zero-indexed, so +1
	const day = String(now.getDate()).padStart(2, '0');
	
	const localDate = `${year}-${month}-${day}`;
	
		// Return the value of the date input field to the local date
	return localDate;
}



function initializeDateTimeInputs(callback) {
	const now = new Date();
	const localDateTime = formatDateTime(now);
	document.getElementById('dateTimeInput').value = setCurrentLocalDate();
	document.getElementById('startDate').value = setCurrentLocalDate();
	document.getElementById('endDate').value = setCurrentLocalDate();
	document.getElementById('ClockOutTimeInput').value = localDateTime;
	document.getElementById('ClockInTimeInput').value = localDateTime;
	
		// Check if assignment exists in the DB
	if (callback)
		callback();
}

async function getRecords() {
	const startDate = document.getElementById('startDate').value;
	const endDate = document.getElementById('endDate').value;
	
	const store = getTransaction(clockstoreName, 'readonly');
	const request = store.getAll();
	request.onsuccess = function(event) {
		const records = event.target.result;
		const filteredRecords = records.filter(record=>{
											   return record.clockInTime && record.clockOutTime && new Date(record.clockInTime) >= new Date(startDate) && new Date(record.clockOutTime) <= new Date(endDate);
											   }
											   );
		
		if (filteredRecords.length === 0) {
			alert('No data exists for the selected time period.');
			return;
		}
		
		const csvContent = generateCSV(filteredRecords);
		downloadCSV(csvContent, `records_ ${startDate}_ ${endDate}.csv`);
	}
	;
}

function generateCSV(records) {
	const csvHeaders = ['Assignment', 'Clock-in Time', 'Clock-out Time', 'Time at Work'];
	const csvRows = [csvHeaders.join(',')];
	
	records.forEach(record=>{
					const row = [`"${record.assignment}"`, `"${record.clockInTime}"`, `"${record.clockOutTime}"`, `"${calculateTimeAtWork(new Date(record.clockInTime), new Date(record.clockOutTime))}"`];
					csvRows.push(row.join(','));
					}
					);
	
	return csvRows.join('\n');
}

function downloadCSV(csvContent, filename) {
	const blob = new Blob([csvContent],{
						  type: 'text/csv'
						  });
	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	a.download = filename;
	a.click();
	URL.revokeObjectURL(url);
}

function calculateTimeAtWork(clockInTime, clockOutTime) {
	const diff = (clockOutTime - clockInTime) / 1000;
		// difference in seconds
	const hours = Math.floor(diff / 3600);
	const minutes = Math.floor((diff % 3600) / 60);
	return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}


										  
										  function formatDateTime(inputDateTime) {
										  const date = new Date(inputDateTime);
										  const pad = (num, size) => num.toString().padStart(size, '0');
										  const year = date.getFullYear();
										  const month = pad(date.getMonth() + 1, 2);
										  const day = pad(date.getDate(), 2);
										  const hours = pad(date.getHours(), 2);
										  const minutes = pad(date.getMinutes(), 2);
										  const seconds = pad(date.getSeconds(), 2);
										  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
										  }
										  
function formatDateTo7AM(dateString) {
		// Directly append the time to the provided date string, assuming it's in the format 'YYYY-MM-DD'
	return `${dateString}T07:00:00`;
}

function formatDateTo5PM(dateString) {
		// Directly append the time to the provided date string, assuming it's in the format 'YYYY-MM-DD'
	return `${dateString}T17:00:00`;
}
										  
										  function getLastWeekRecords() {
										  const endDate = new Date();
										  const startDate = new Date();
										  startDate.setDate(endDate.getDate() - 7);
										  document.getElementById('startDate').value = formatDateTime(startDate);
										  document.getElementById('endDate').value = formatDateTime(endDate);
										  getRecords();
										  }
										  
										  function getLastMonthRecords() {
										  const endDate = new Date();
										  const startDate = new Date();
										  startDate.setMonth(endDate.getMonth() - 1);
										  document.getElementById('startDate').value = formatDateTime(startDate);
										  document.getElementById('endDate').value = formatDateTime(endDate);
										  getRecords();
										  }
										  
										  function clearIndexedDB() {
										  const request = indexedDB.deleteDatabase(dbName);
										  request.onsuccess = function() {
										  alert('IndexedDB cleared.');
										  initDB();
										  }
										  ;
										  request.onerror = function(event) {
										  console.error('IndexedDB clear error:', event.target.errorCode);
										  }
										  ;
										  }
										  
										  function getAssignmentsByDate(date) {
										  const store = getTransaction(clockstoreName, 'readonly');
										  const index = store.index('date_index');
										  // Assumes you have an index on date and assignment
										  
										  const query = IDBKeyRange.only([date]);
										  const request = index.getAll(query);
										  
										  return new Promise((resolve,reject)=>{
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 }
															 ;
															 request.onerror = function(event) {
															 reject('Failed to retrieve assignment');
															 }
															 ;
															 }
															 );
										  }
										  
										  // Example usage:
										  /*
										   getAssignmentByDateAndSummary('2024-08-29', 'Morning Shift').then((result) => {
										   if (result) {
										   console.log('Assignment found:', result);
										   } else {
										   console.log('Assignment not found');
										   }
										   }).catch((error) => {
										   console.error(error);
										   });
										   
										   
										   */
										  
										  let currentPrimaryKey;
										  let currentWhichTime;
										  
										  
										  function saveDateTime() {
										  const dateTimeInput = document.getElementById('dateTimeInputModal').value;
										  if (dateTimeInput) {
										  updateRecord(currentPrimaryKey, currentWhichTime, dateTimeInput);
										  }
										  closeDateTimeModal();
										  }
										  
										  function closeDateTimeModal() {
										  document.getElementById('dateTimeModal').style.display = 'none';
										  }
										  
										  async function editTimes(primaryKey, whichTime) {
										  currentPrimaryKey = primaryKey;
										  currentWhichTime = whichTime;
										  
										  // Display the modal
										  const modal = document.getElementById('dateTimeModal');
										  modal.style.display = 'block';
										  
										  const record = await getRecordById(primaryKey);
										  const localDateTime = formatDateTime(new Date());
										  
										  // Set the default value of the date-time picker
										  const dateTimeInput = document.getElementById('dateTimeInputModal');
										  dateTimeInput.value = whichTime === 'clockIn' ? record.clockInTime || localDateTime : record.clockOutTime || localDateTime;
										  }

										  
										  async function updateRecord(primaryKey, whichTime, selectedDateTime) {
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const updateRequest = store.get(primaryKey);
										  
										  updateRequest.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record based on whichTime
										  if (whichTime === 'clockIn') {
										  record.clockInTime = selectedDateTime;
										  } else if (whichTime === 'clockOut') {
										  record.clockOutTime = selectedDateTime;
										  }
										  
										  // Save the updated record back into the object store
										  const putRequest = store.put(record);
										  putRequest.onsuccess = function() {
										  // Update the displayed value in the corresponding cell
										  const cellId = whichTime === 'clockIn' ? 'clockIn' + primaryKey : 'clockOut' + primaryKey;
										  const cell = document.getElementById(cellId);
										  if (cell) {
										  cell.textContent = selectedDateTime + " ";
										  // Refresh the Edit button
										  const editButton = document.createElement("button");
										  editButton.textContent = "Edit";
										  editButton.onclick = () => editTimes(primaryKey, whichTime);
										  cell.appendChild(editButton);
										  }
										  };
										  putRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.error);
										  };
										  }
										  };
										  updateRequest.onerror = function(event) {
										  console.error('Error retrieving record:', event.target.error);
										  };
										  }
										  
										  // Helper function to retrieve a record by its primary key
										  async function getRecordById(primaryKey) {
										  return new Promise((resolve, reject) => {
															 const store = getTransaction(clockstoreName, 'readonly');
															 const request = store.get(primaryKey);
															 
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 };
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 };
															 });
										  }


										  async function clockIn(primaryKey) {
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  const store = getTransaction(clockstoreName, 'readwrite');
										  const request = store.get(primaryKey);
										  
										  request.onsuccess = function(event) {
										  const record = event.target.result;
										  if (record) {
										  // Update the record with clockInTime
										  record.clockInTime = localDateTime; // Current time
											// redundant to update the assignemnt here as well but just in case the user happens to click the clockin or clockout faster than the debounce time of 500 ms - it will capture the updated assignment here.
										record.assignment = document.getElementById('storedassignmentInput'+primaryKey).value;
										  // Save the updated record back into the object store
										  const updateRequest = store.put(record);
										  
										  updateRequest.onsuccess = function(event) {
										  // Update the UI after successful clock in
										  const clockInCell = document.getElementById('clockIn' + primaryKey);
										  clockInCell.textContent = localDateTime + " ";
										  
										  // Add the Edit button next to the clockIn time
										  const editButton = document.createElement("button");
										  editButton.textContent = "Edit";
										  editButton.onclick = () => editTimes(primaryKey, "clockIn"); // Pass the id to editTimes
										  clockInCell.appendChild(editButton);
										  };
										  
										  updateRequest.onerror = function(event) {
										  console.error('Error updating record:', event.target.errorCode);
										  };
										  } else {
										  console.log('Record not found');
										  // Handle case where the record does not exist
										  const assignment = document.getElementById('storedassignmentInput').value;
										  const formattedToday = document.getElementById('dateTimeInput').value;
										  const clockInTime = document.getElementById('ClockInTimeInput').value;
										  if (formattedToday) {
										  const newStore = getTransaction(clockstoreName, 'readwrite');
										  newStore.put({
													   date: formattedToday,
													   clockInTime: clockInTime, // Use localDateTime here for consistency
													   assignment: assignment,
													   clockOutTime: null, // Leave clockOutTime as null
													   });
										  
										  displayTodaysAssignment();
										  } else {
										  alert('Please enter your assignment and select a date/time.');
										  }
										  }
										  };
										  
										  request.onerror = function(event) {
										  console.log('Failed to retrieve record:', event.target.errorCode);
										  };
										  }


										  
	// Global variables for session pay rates
const callRate = 200; // Example rate, update accordingly
const nonCallRate = 250; // Example rate, update accordingly

async function clockOut(primaryKey) {
	const store = getTransaction(clockstoreName, 'readwrite');
	if (!store) {
		alert('Database store is not available. Please try again later.');
		return;
	}
	
	const request = store.get(primaryKey);
	
	request.onsuccess = function(event) {
		const record = event.target.result;
		if (record) {
			const clockOutTimeInput = document.getElementById('ClockOutTimeInput' + primaryKey);
			if (!clockOutTimeInput || !clockOutTimeInput.value) {
				alert("Please provide a valid clock-out time.");
				return;
			}
			
			const clockOutTime = clockOutTimeInput.value;
			const clockInTime = record.clockInTime ? new Date(record.clockInTime) : formatDateTo7AM(record.date);
			
				// Validation: clockOutTime must be at least 30 minutes after clockInTime
			const clockOut = new Date(clockOutTime);
			if ((clockOut - clockInTime) < (30 * 60 * 1000)) {
				alert("Clock out time must be at least 30 minutes after clock in time.");
				return;
			}
			
				// Update the record with clockOutTime
			record.clockOutTime = clockOutTime;
			record.assignment = document.getElementById('storedassignmentInput' + primaryKey).value;
			
				// Calculate hours worked
			record.hoursWorked = calculateHoursWorked(clockInTime, clockOut);
			
				// Calculate overtime
			record.overtime = calculateOvertime(clockOut, record.assignment, record.date, clockInTime);
			
				// Calculate session pay
			record.sessionPay = calculateSessionPay(record.overtime, record.assignment);
			
				// Save the updated record back into the object store
			const updateRequest = store.put(record);
			
			updateRequest.onsuccess = function(event) {
					// Update the UI after successful clock out
				const clockOutCell = document.getElementById('clockOut' + primaryKey);
				clockOutCell.textContent = clockOutTime + " ";
				
					// Add the Edit button next to the clockOut time
				const editButton = document.createElement("button");
				editButton.textContent = "Edit";
				editButton.onclick = () => editTimes(primaryKey, "clockOut");
				clockOutCell.appendChild(editButton);
			};
			
			updateRequest.onerror = function(event) {
				console.error('Error updating record:', event.target.errorCode);
			};
		} else {
			console.log('Record not found');
			const assignmentInput = document.getElementById('storedassignmentInput');
			const dateTimeInput = document.getElementById('dateTimeInput');
			
			if (!assignmentInput || !dateTimeInput) {
				alert('Please enter your assignment and select a date/time.');
				return;
			}
			
			const assignment = assignmentInput.value;
			const formattedToday = dateTimeInput.value;
			
			if (formattedToday) {
				const newStore = getTransaction(clockstoreName, 'readwrite');
				if (!newStore) {
					alert('Database store is not available. Please try again later.');
					return;
				}
				
				const clockOutTime = document.getElementById('ClockOutTimeInput').value;
				const clockInTime = formatDateTo7AM(formattedToday);
				const clockOut = new Date(clockOutTime);
				if ((clockOut - clockInTime) < (30 * 60 * 1000)) {
					alert("Clock out time must be at least 30 minutes after clock in time.");
					return;
				}
				
				const overtime = calculateOvertime(clockOut, assignment, formattedToday, clockInTime);
				
				newStore.put({
							 date: formattedToday,
							 clockInTime: clockInTime, // Default clock in time 7 AM
							 assignment: assignment,
							 clockOutTime: clockOutTime,
							 hoursWorked: calculateHoursWorked(clockInTime, clockOut),
							 overtime: overtime,
							 sessionPay: calculateSessionPay(overtime, assignment),
							 });
				
				displayTodaysAssignment();
			} else {
				alert('Please enter your assignment and select a date/time.');
			}
		}
	};
	
	request.onerror = function(event) {
		console.log('Failed to retrieve record:', event.target.errorCode);
	};
}


	// Function to calculate hours worked in 15-minute increments
function calculateHoursWorked(clockInTime, clockOutTime) {
	const diff = clockOutTime - clockInTime; // Difference in milliseconds
	const diffInMinutes = Math.round(diff / (1000 * 60)); // Difference in minutes
	const roundedMinutes = Math.ceil(diffInMinutes / 15) * 15; // Round up to nearest 15 minutes
	const hoursWorked = roundedMinutes / 60; // Convert to hours
	return hoursWorked;
}

function calculateOvertime(clockOutTime, assignment, date, clockInTime) {
		// Extract day of the week without using new Date()
	const dayOfWeek = new Date(`${date}T00:00:00`).getDay(); // Avoids GMT/UTC issue by using midnight time
	
	let overtime = 0;
	
		// If the day is Saturday (6) or Sunday (0), calculate total time as overtime
	if (dayOfWeek === 0 || dayOfWeek === 6) {
		overtime = (new Date(clockOutTime) - new Date(clockInTime)) / (1000 * 60 * 60); // Calculate total hours
	} else {
		const endOfDay = formatDateTo5PM(date); // 5 PM of the same day
		
		if (assignment.includes("CC")) {
				// Calculate next day at 1 AM without new Date()
			const nextDay1AM = `${increaseDateByOneDay(date)}T01:00:00`;
			
				// Overtime if clockOut is after 1 AM the next day
			if (clockOutTime > nextDay1AM) {
				overtime = (new Date(clockOutTime) - new Date(nextDay1AM)) / (1000 * 60 * 60); // Hours in overtime
			}
			
				// Overtime if clockIn is before 2 PM
			const cutoffTime2PM = `${date}T14:00:00`;
			if (clockInTime < cutoffTime2PM) {
				overtime += (new Date(cutoffTime2PM) - new Date(clockInTime)) / (1000 * 60 * 60); // Add early overtime hours
			}
		} else {
				// Standard overtime calculation for non-CC assignments
			if (clockOutTime > endOfDay) {
				overtime = (new Date(clockOutTime) - new Date(endOfDay)) / (1000 * 60 * 60); // Hours in overtime
			}
		}
	}
	
		// Round overtime to the nearest 15 minutes
	return Math.ceil(overtime * 4) / 4;
}

	// Helper function to increase date by one day
function increaseDateByOneDay(dateString) {
	const dateParts = dateString.split('-');
	const year = parseInt(dateParts[0], 10);
	const month = parseInt(dateParts[1], 10) - 1; // Month is zero-based in JavaScript
	const day = parseInt(dateParts[2], 10);
	
	const date = new Date(year, month, day);
	date.setDate(date.getDate() + 1);
	
		// Format back to 'YYYY-MM-DD'
	const newYear = date.getFullYear();
	const newMonth = (date.getMonth() + 1).toString().padStart(2, '0');
	const newDay = date.getDate().toString().padStart(2, '0');
	
	return `${newYear}-${newMonth}-${newDay}`;
}



	// Function to calculate session pay based on overtime and assignment
function calculateSessionPay(overtime, assignment) {
	const rate = (assignment.includes("C1M") || assignment.includes("CC")) ? callRate : nonCallRate;
	return overtime * rate;
}


// Create a debounced version of handleUpdatedAssignment
const debouncedHandleUpdatedAssignment = debounce(handleUpdatedAssignment, 500);


async function handleUpdatedAssignment(primaryKey){
	const store = getTransaction(clockstoreName, 'readwrite');
	const request = store.get(primaryKey);
	
	request.onsuccess = function(event) {
		const record = event.target.result;
		if (record) {
				// Update the record with clockOutTime
			record.assignment = document.getElementById('storedassignmentInput'+primaryKey).value;
			
				// Save the updated record back into the object store
			const updateRequest = store.put(record);
			
			updateRequest.onsuccess = function(event) {
				console.log("Assignment updated");
			};
			updateRequest.onerror = function(event) {
				console.error('Error updating record:', event.target.errorCode);
			};
		}else {
			console.log('Record not found');
		}
	};
		request.onerror = function(event) {
			console.log('Failed to retrieve record:', event.target.errorCode);
		};
	
}
										  
										  async function displayTodaysAssignment() {
										  // Clear and reset the clock in/clock out times and buttons
										  const now = new Date();
										  const localDateTime = formatDateTime(now);
										  const formattedToday = document.getElementById('dateTimeInput').value;
										  // Reset clockIn, clockOut times and buttons
										  document.getElementById('ClockOutTimeInput').value = localDateTime;
										  document.getElementById('ClockInTimeInput').value = formatDateTo7AM(formattedToday); // set it to the day of assignments 7 am
										  document.getElementById('storedassignmentInput').value = null;
										  //document.getElementById('clockInOut').style.display = "block"; // Ensure clockInOut is visible

										  
										  
										  try {
										  // Check if today's assignment is already in the IndexedDB
										  const todayAssignment = await getAssignmentFromDB(formattedToday);
										  
										  if (todayAssignment) {
										  // Assignment for today exists in IndexedDB
										  document.getElementById('assignmentInput').value = todayAssignment.assignment; 
										  document.getElementById('storedassignmentInput').value = todayAssignment.assignment;
										  }
										  
										  // Get assignments for today and update the table
										  const result = await getAssignmentsByDate(formattedToday);
										  const mytable = document.getElementById("mytable");
										  mytable.textContent = ""; // Clear existing table contents
										  
										  if (result && result.length > 0) {
										  // If there are results, hide the clockInOut section
										  //document.getElementById('clockInOut').style.display = "none";
										  
										  result.forEach(function (individualresult) {
														 //console.log(individualresult);
														 
														 // Create a new row
														 const myrow = document.createElement("tr");
														 myrow.id = `row${individualresult.id}`;
														 // Append other details like id, date, assignment
														 for (const cell of [
																			 //individualresult.id,
																			 individualresult.date,
																			 ]) {
														 const tableCell = document.createElement("td");
														 tableCell.textContent = cell;
														 myrow.appendChild(tableCell);
														 }
														 //Assignment Cell
														 const assignmentCell = document.createElement("td");
														 assignmentCell.id = "assignment" + individualresult.id; // Add unique ID
														 const assignmentInputfromTable = document.createElement("input");
														 assignmentInputfromTable.type="text";
														 assignmentInputfromTable.id="storedassignmentInput"+individualresult.id;
														 assignmentInputfromTable.value=individualresult.assignment;
														 assignmentInputfromTable.oninput = () => debouncedHandleUpdatedAssignment(individualresult.id);
														 
											  assignmentCell.appendChild(assignmentInputfromTable);
														myrow.appendChild(assignmentCell);
												  		// Clock In Time Cell
														 const clockInCell = document.createElement("td");
														 clockInCell.id = "clockIn" + individualresult.id; // Add unique ID
														 
														 if (individualresult.clockInTime) {
														 // If clockInTime exists, display it and add an Edit button
														 clockInCell.textContent = individualresult.clockInTime + " ";
														 const editButton = document.createElement("button");
														 editButton.textContent = "Edit";
														 editButton.onclick = () => editTimes(individualresult.id, "clockIn"); // Pass the id to editTimes
														 clockInCell.appendChild(editButton);
														 } else {
														 // If clockInTime is null, add a Clock In button
														 const clockInButton = document.createElement("button");
														 clockInButton.textContent = "Clock In";
														 clockInButton.onclick = () => clockIn(individualresult.id); // Pass the id to clockIn
														 clockInCell.appendChild(clockInButton);
														 }
														 myrow.appendChild(clockInCell);
														 
														 // Clock Out Time Cell
														 const clockOutCell = document.createElement("td");
														 clockOutCell.id = "clockOut" + individualresult.id; // Add unique ID
														 
														 if (individualresult.clockOutTime) {
														 // If clockOutTime exists, display it and add an Edit button
														 clockOutCell.textContent = individualresult.clockOutTime + " ";
														 const editButton = document.createElement("button");
														 editButton.textContent = "Edit";
														 editButton.onclick = () => editTimes(individualresult.id,"clockOut"); // Pass the id to editTimes
														 clockOutCell.appendChild(editButton);
														 } else {
														 // If clockOutTime is null, add a Clock Out button
														 const ClockOutTimeInputfromTable = document.createElement("input");
														 ClockOutTimeInputfromTable.type="datetime-local";
														 ClockOutTimeInputfromTable.id="ClockOutTimeInput"+ individualresult.id;
														 ClockOutTimeInputfromTable.value = localDateTime;
														 const clockOutButton = document.createElement("button");
														 clockOutButton.textContent = "Clock Out";
														 clockOutButton.onclick = () => clockOut(individualresult.id); // Pass the id to clockOut
														 clockOutCell.appendChild(ClockOutTimeInputfromTable);
														 clockOutCell.appendChild(clockOutButton);
														 
														 }
														 myrow.appendChild(clockOutCell);
														 
														 // Delete Button Cell
														 const deleteCell = document.createElement("td");
														 const deleteButton = document.createElement("button");
														 deleteButton.textContent = "X";
														 deleteButton.onclick = () => deleteRecord(individualresult.id); // Pass the id to deleteRecord
														 deleteCell.appendChild(deleteButton);
														 myrow.appendChild(deleteCell);
														 
														 // Append the row to the table
														 mytable.appendChild(myrow);
														 });
										  } else {
										  // If no results, ensure clockInOut is visible
										  //document.getElementById('clockInOut').style.display = "block";
										  console.log("No assignments found for today.");
										  }
										  } catch (error) {
										  console.error('Error displaying today\'s assignment:', error);
										  }
										  }


										  async function deleteRecord(primaryKey) {
										  const store = getTransaction(clockstoreName, 'readwrite'); // Open a readwrite transaction
										  const request = store.delete(primaryKey); // Delete the record with the given primary key
										  
										  request.onsuccess = function(event) {
										  console.log(`Record with primaryKey ${primaryKey} deleted successfully!`);
										  
										  // Remove the corresponding row from the UI
										  const rowToDelete = document.getElementById(`row${primaryKey}`);
										  if (rowToDelete) {
										  rowToDelete.remove(); // Remove the row from the table
										  }
										  };
										  
										  request.onerror = function(event) {
										  console.error('Error deleting record:', event.target.error); // Use event.target.error for more detailed error information
										  };
										  }


										  
										  
										  function getRecordsByDate(date, callback) {
										  const store = getTransaction(clockstoreName, 'readonly');
										  const index = store.index('date_index');
										 
										  // Query by date
										  
										  const keyRange = IDBKeyRange.only([date]);
										  
										  //const request = index.openKeyCursor(keyRange);
										  const request = index.getAll(keyRange);
										  request.onsuccess = function(event) {
										  const records = event.target.result; console.log(records);
										  if (records) { callback(records);} else {console.log ("No records");}
										  // Handle the array of records
										  }
										  ;
										  
										  request.onerror = function(event) {
										  console.error('Error fetching records by date:', event.target.errorCode);
										  }
										  ;
										  }

										  
										  // Function to get an assignment from IndexedDB
										  function getAssignmentFromDB(date) {
										  return new Promise((resolve,reject)=>{
															 const store = getTransaction(calstoreName, 'readonly');
															 const request = store.get(date);
															 
															 request.onsuccess = function(event) {
															 resolve(event.target.result);
															 }
															 ;
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 }
															 ;
															 }
															 );
										  }
										  
										  // Function to update assignment in IndexedDB
										  function updateAssignmentInDB(date, summary) {
										  return new Promise((resolve,reject)=>{
															 const store = getTransaction(calstoreName, 'readwrite');
															 const request = store.get(date);
															 
															 request.onsuccess = function(event) {
															 const result = event.target.result;
															 if (result) {
															 // Replace the existing assignment with the new summary
															 store.put({
																	   id: date,
																	   date: date,
																	   assignment: summary
																	   });
															 } else {
															 // Store new assignment
															 store.put({
																	   id: date,
																	   date: date,
																	   assignment: summary
																	   });
															 }
															 resolve();
															 }
															 ;
															 
															 request.onerror = function(event) {
															 reject(event.target.error);
															 }
															 ;
															 }
															 );
										  }
										  
										  // Utility functions (unchanged)
										  function parseCustomDate(dateString) {
										  const year = dateString.slice(0, 4);
										  const month = dateString.slice(4, 6) - 1;
										  // Months are 0-indexed in JavaScript
										  const day = dateString.slice(6, 8);
										  
										  return new Date(year,month,day);
										  }
										  
										  function formatQDate(date) {
										  return date.split('T')[0];
										  }
										  
										  function parseICalendar(data) {
										  const events = [];
										  const lines = data.split('\n');
										  let event = null;
										  
										  for (const line of lines) {
										  if (line.startsWith('BEGIN:VEVENT')) {
										  event = {
										  details: {}
										  };
										  } else if (line.startsWith('SUMMARY:')) {
										  event.details.summary = line.replace('SUMMARY:', '');
										  } else if (line.startsWith('DTSTART;VALUE=DATE:')) {
										  event.details.start = line.replace('DTSTART;VALUE=DATE:', '');
										  } else if (line.startsWith('DTEND;VALUE=DATE:')) {
										  event.details.end = line.replace('DTEND;VALUE=DATE:', '');
										  } else if (line.startsWith('END:VEVENT')) {
										  if (event) {
										  events.push(event);
										  event = null;
										  }
										  }
										  }
										  return events;
										  }
										  
										  function convertUrlPrefix(url) {
										  const oldPrefix = "https://app.qgenda.com/ical";
										  const newPrefix = "/clock/qgenda/ical";
										  
										  // Replace the old prefix with the new prefix
										  if (url.startsWith(oldPrefix)) {
										  return url.replace(oldPrefix, newPrefix);
										  } else {
										  return url;
										  // Return the original URL if it doesn't match the old prefix
										  }
										  }
										  
										  function checkAndDisplayAssignment() {
										  if (db && db.objectStoreNames.contains(calstoreName)) {
										  displayTodaysAssignment();
										  } else {
										  console.error('Database not initialized or calstoreName does not exist.');
										  }
										  }
										  
										  // Ensure proper sequencing
										  window.onload = function() {
										  initDB(function() {
												 initializeDateTimeInputs(function() {
																		  checkAndDisplayAssignment();
																		  });
												 });
										  }
										  ;
										  
										  document.getElementById('qgendaurl').addEventListener('blur', function() {
																								const url = this.value;
																								if (url) {
																								handleURLupdate(url);
																								}
																								});
										  
										  function debounce(func, delay) {
										  let timeout;
										  return function(...args) {
										  clearTimeout(timeout);
										  timeout = setTimeout(()=>func.apply(this, args), delay);
										  }
										  ;
										  }
										  
										  document.getElementById('assignmentInput').addEventListener('input', debounce(function() {
																														const url = this.value;
																														if (url) {
																														handleUpdatedAssignment(url);
																														}
																														}, 500));
										  // Adjust the delay as needed
										  
										  document.getElementById('dateTimeInput').addEventListener('change', function() {
																									const url = this.value;
																									if (url) {
																									displayTodaysAssignment();
																									}
																									});
										  
										  window.addEventListener('focus', function() {
																  //console.log('Window is back in focus');
																  initializeDateTimeInputs(function() {
																						   checkAndDisplayAssignment();
																						   });
																  
																  });
										  
										  function handleDateUpdate(event) {
										  const selectedDate = event.target.value;
										  if (selectedDate) {
										  // Your logic here
										  console.log('User selected date:', selectedDate);
										  }
										  }
										  // Service Worker registration
										  if ('serviceWorker'in navigator) {
										  window.addEventListener('load', function() {
																  navigator.serviceWorker.register('./service-worker.js').then(function(registration) {
																															   console.log('ServiceWorker registration successful with scope: ', registration.scope);
																															   }).catch(function(error) {
																																		console.log('ServiceWorker registration failed: ', error);
																																		});
																  });
										  }
										  </script>
										  </body>
										  </html>
										  
