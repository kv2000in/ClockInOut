<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>Clock In/Out Tracker</title>
				<link rel="manifest" href="./manifest.json">
					<link rel="icon" href="./icons/favicon.ico" type="image/x-icon">
						<style>
							body {
								font-family: Arial, sans-serif;
								margin: 50px;
							}
						.container {
							max-width: 300px;
							margin: auto;
							text-align: center;
						}
						input[type="text"], input[type="datetime-local"], button {
							padding: 10px;
							margin: 5px;
							width: 100%;
						}
						</style>
	</head>
	<body>
		<div class="container">
			<h1>Clock In/Out</h1>
			<input type="text" id="qgendaurl" placeholder="Enter Qgenda Calendar URL">
				<input type="text" id="assignmentInput" placeholder="Enter your assignment">
					<input type="datetime-local" id="dateTimeInput">
						<button id="clockInButton" onclick="clockIn()">Clock In</button>
						<button id="clockOutButton" onclick="clockOut()" disabled>Clock Out</button>
						
						<h2>Get Records</h2>
						<input type="datetime-local" id="startDate">
							<input type="datetime-local" id="endDate">
								<button onclick="getRecords()">Get Records</button>
								<button onclick="getLastWeekRecords()">Last Week</button>
								<button onclick="getLastMonthRecords()">Last Month</button>
								<button onclick="clearIndexedDB()">Clear IndexedDB</button>
								</div>
		
		<script>
			const dbName = 'ClockInOutDB';
			const storeName = 'recordsStore';
			let db;
			
			function initDB() {
				const request = indexedDB.open(dbName, 1);
				
				request.onupgradeneeded = function(event) {
					db = event.target.result;
					db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
				};
				
				request.onsuccess = function(event) {
					db = event.target.result;
					loadQGendaURL();
				};
				
				request.onerror = function(event) {
					console.error('IndexedDB error:', event.target.errorCode);
				};
			}
		
		function getTransaction(storeName, mode) {
			const transaction = db.transaction([storeName], mode);
			return transaction.objectStore(storeName);
		}
		
		async function saveQGendaURL(url) {
			const store = getTransaction(storeName, 'readwrite');
			store.put({ id: 'qgendaurl', value: url });
		}
		
		async function loadQGendaURL() {
			const store = getTransaction(storeName, 'readonly');
			const request = store.get('qgendaurl');
			request.onsuccess = function(event) {
				const result = event.target.result;
				if (result) {
					document.getElementById('qgendaurl').value = result.value;
				}
			};
		}
		
		async function saveRecord(record) {
			const store = getTransaction(storeName, 'readwrite');
			store.put(record);
		}
		
		async function getRecords() {
			const startDate = new Date(document.getElementById('startDate').value).toLocaleString();
			const endDate = new Date(document.getElementById('endDate').value).toLocaleString();
			
			const store = getTransaction(storeName, 'readonly');
			const request = store.getAll();
			request.onsuccess = function(event) {
				const records = event.target.result;
				const filteredRecords = records.filter(record => {
													   return record.clockInTime &&
													   record.clockOutTime &&
													   new Date(record.clockInTime) >= new Date(startDate) &&
													   new Date(record.clockOutTime) <= new Date(endDate);
													   });
													   
													   if (filteredRecords.length === 0) {
														   alert('No data exists for the selected time period.');
														   return;
													   }
													   
													   const csvContent = generateCSV(filteredRecords);
													   downloadCSV(csvContent, `records_${formatDate(startDate)}_${formatDate(endDate)}.csv`);
			};
		}
		
		function generateCSV(records) {
			const csvHeaders = ['Assignment', 'Clock-in Time', 'Clock-out Time', 'Time at Work'];
			const csvRows = [csvHeaders.join(',')];
			
			records.forEach(record => {
							const row = [
										 `"${record.assignment}"`,
										 `"${record.clockInTime}"`,
										 `"${record.clockOutTime}"`,
										 `"${calculateTimeAtWork(new Date(record.clockInTime), new Date(record.clockOutTime))}"`
										 ];
							csvRows.push(row.join(','));
							});
							
							return csvRows.join('\n');
		}
		
		function downloadCSV(csvContent, filename) {
			const blob = new Blob([csvContent], { type: 'text/csv' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = filename;
			a.click();
			URL.revokeObjectURL(url);
		}
		
		function calculateTimeAtWork(clockInTime, clockOutTime) {
			const diff = (clockOutTime - clockInTime) / 1000; // difference in seconds
			const hours = Math.floor(diff / 3600);
			const minutes = Math.floor((diff % 3600) / 60);
			return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
		}
		
		function formatDate(date) {
			const d = new Date(date);
			return d.toLocaleDateString().replace(/\//g, '');
												  }
												  
												  function formatDateTime(inputDateTime) {
												  const date = new Date(inputDateTime);
												  const pad = (num, size) => num.toString().padStart(size, '0');
												  const year = date.getFullYear();
												  const month = pad(date.getMonth() + 1, 2);
												  const day = pad(date.getDate(), 2);
												  const hours = pad(date.getHours(), 2);
												  const minutes = pad(date.getMinutes(), 2);
												  const seconds = pad(date.getSeconds(), 2);
												  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
												  }
												  
												  function getLastWeekRecords() {
												  const endDate = new Date();
												  const startDate = new Date();
												  startDate.setDate(endDate.getDate() - 7);
												  document.getElementById('startDate').value = formatDateTime(startDate);
												  document.getElementById('endDate').value = formatDateTime(endDate);
												  getRecords();
												  }
												  
												  function getLastMonthRecords() {
												  const endDate = new Date();
												  const startDate = new Date();
												  startDate.setMonth(endDate.getMonth() - 1);
												  document.getElementById('startDate').value = formatDateTime(startDate);
												  document.getElementById('endDate').value = formatDateTime(endDate);
												  getRecords();
												  }
												  
												  function clearIndexedDB() {
												  const request = indexedDB.deleteDatabase(dbName);
												  request.onsuccess = function() {
												  alert('IndexedDB cleared.');
												  initDB();
												  };
												  request.onerror = function(event) {
												  console.error('IndexedDB clear error:', event.target.errorCode);
												  };
												  }
												  
												  async function clockIn() {
												  const assignment = document.getElementById('assignmentInput').value;
												  const dateTime = document.getElementById('dateTimeInput').value;
												  
												  if (assignment && dateTime) {
												  await saveRecord({
																   clockInTime: new Date(dateTime).toLocaleString(),
																   assignment: assignment,
																   clockOutTime: null,
																   });
												  
												  
												  document.getElementById('clockInButton').disabled = true;
												  document.getElementById('clockOutButton').disabled = false;
												  } else {
												  alert('Please enter your assignment and select a date/time.');
												  }
												  }
												  
												  async function clockOut() {
												  const dateTime = document.getElementById('dateTimeInput').value;
												  
												  if (dateTime) {
												  const store = getTransaction(storeName, 'readwrite');
												  const request = store.openCursor(null, 'prev');
												  request.onsuccess = async function(event) {
												  const cursor = event.target.result;
												  if (cursor) {
												  if (cursor.value.clockOutTime === null) {
												  cursor.update({
																...cursor.value,
																clockOutTime: new Date(dateTime).toLocaleString()
																});
												  
												  
												  document.getElementById('clockInButton').disabled = false;
												  document.getElementById('clockOutButton').disabled = true;
												  } else {
												  alert('No matching clock-in record found.');
												  }
												  } else {
												  alert('No clock-in record found.');
												  }
												  };
												  request.onerror = function(event) {
												  console.error('Cursor error:', event.target.errorCode);
												  };
												  } else {
												  alert('Please select a date/time.');
												  }
												  }
												  
												  async function displayTodaysAssignment() {
												  const url = document.getElementById('qgendaurl').value;
												  const calendarData = await fetchCalendar(url);
												  
												  if (calendarData) {
												  const events = parseICalendar(calendarData);
												  const todayEvents = events.filter(event => isToday(new Date(event.start)));
												  if (todayEvents.length > 0) {
												  document.getElementById('assignmentInput').value = todayEvents[0].summary;
												  }
												  }
												  }
												  
												  async function fetchCalendar(url) {
												  try {
												  const response = await fetch(url);
												  if (response.ok) {
												  return await response.text();
												  } else {
												  console.error('Error fetching calendar:', response.statusText);
												  }
												  } catch (error) {
												  console.error('Fetch error:', error);
												  }
												  }
												  
												  function parseICalendar(data) {
												  // Implement iCalendar parsing logic here
												  return [];
												  }
												  
												  function isToday(date) {
												  const today = new Date();
												  return date.getFullYear() === today.getFullYear() &&
												  date.getMonth() === today.getMonth() &&
												  date.getDate() === today.getDate();
												  }
												  
												  initDB();
												  </script>
	</body>
</html>

